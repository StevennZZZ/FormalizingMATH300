<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATH300 in Lean 4</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        header {
            text-align: center;
            padding: 10px;
            background-color: #f2f2f2;
        }

        main {
            padding: 20px;
        }

        section {
            border-bottom: 1px solid #ccc;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }

        code {
            color:dodgerblue;
        }

        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        footer {
            text-align: center;
            padding: 10px;
            background-color: #f2f2f2;
        }

        .unfinished {
            color:rgb(255, 0, 8);
            text-decoration-line: underline;
            text-decoration-style: wavy;
        }

        .single_command {
            color:rgb(179, 0, 255);
        }

        .sorry {
            color:crimson
        }

        .comment {
            color:darkgreen;
        }

        .lines {
            color:dodgerblue;
        }

        .box{
            width: 70px;
            height: 18px;
            border: 1px solid black;
            margin: 0;
            padding: 0;
        }
        /*added directory part*/
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 300px;
            height: 100%;
            background-color: #f2f2f2;
            overflow-y: auto;
            padding: 20px;
        }

        /* 选择顶级的列表项并为它们添加外边距 */
        .sidebar > ul > li {
            margin-bottom: 30px; /* 调整这个值以设置所需的间距 */
        }


        main {
            margin-left: 320px;
            padding: 20px;
        }

        .hidden {
            display: none;
        }

        /* 将以下样式添加到您现有的 <style> 标签内 */
        #expand-all, #collapse-all {
            display: block;
            width: 90%; /* Adjust as necessary */
            margin: 10px auto;
            padding: 5px;
            cursor: pointer;
            background-color: #e7e7e7; /* Light grey background */
            border: none;
            border-radius: 5px;
        }

        /* Optional: Add hover effect for buttons */
        #expand-all:hover, #collapse-all:hover {
            background-color: #dcdcdc; /* Slightly darker grey on hover */
        }

        .sidebar {
            transition: left 0.3s; /* 添加平滑的过渡效果 */
        }

        .sidebar-hidden {
            left: -350px; /* 当sidebar隐藏时，将其向左移出屏幕 */
        }

        #toggle-sidebar-btn {
            position: fixed;
            left: 10px;
            top: 10px; /* 或者 bottom: 0，取决于您希望按钮出现的位置 */
            z-index: 1000; /* 确保按钮在最上层 */
            /* 其他样式根据需要添加，例如背景色、边框等 */
        }

        main {
            transition: margin-left 0.3s; /* 添加过渡效果 */
            margin-left: 320px; /* 初始时与侧边栏有间隙 */
            padding: 20px;
        }

        .full-width {
            margin-left: 0; /* 当侧边栏隐藏时，移除左边距 */
        }








    </style>
</head>
<body>

    <header>
        <h1>MATH300 in Lean 4</h1>
    </header>
    <button id="toggle-sidebar-btn">Close Bar</button>
    <nav class="sidebar">
        <ul>
            <li class="chapter">
                <a href="#c1">Chapter 1: Preliminaries</a>
                <ul>
                    <li><a href="#c1-0">1.0 Introduction to Lean 4 - Interactive Proof Assistant</a></li>
                    <li><a href="#c1-1">1.1. Elementary properties of the integers</a></li>
                    <li><a href="#c1-2">1.2. Definitions</a></li>
                    <li><a href="#c1-3">1.3. Elementary properties of the integers (again)</a></li>
                </ul>
            </li>
            <li class="chapter">
                <a href="#c2">Chapter 2: Logic and mathematical language</a>
                <ul>
                    <li><a href="#c2-1">2.1. Negations (¬)</a></li>
                    <li><a href="#c2-2">2.2. And (∧) and Or (∨) / Conjunction and Disjunction</a></li>
                    <li><a href="#c2-3">2.3 If, then</a></li>
                    <li><a href="#c2-4">2.4. Quantifiers</a></li>
                </ul>
            </li>
            <li class="chapter">
                <a href="#c3">Chapter 3: Writing Proofs</a>
                <ul>
                    <li><a href="#c3-1">3.1. Direct Proofs</a></li>
                    <li><a href="#c3-2">3.2. Proof by Cases (a.k.a. proof by exhaustion)</a></li>
                    <li><a href="#c3-3">3.3. Proof by contrapositive</a></li>
                    <li><a href="#c3-4">3.4. Proof by contradiction</a></li>
                    <li><a href="#c3-5">3.5. Proof of an if-and-only-if Statement</a></li>
                </ul>
            </li>
            <li class="chapter">
                <a href="#c4">Chapter 4: Proofs Involving Quantifiers</a>
                <ul>
                    <li><a href="#c4-1">4.1. Proofs of for all statements</a></li>
                    <li><a href="#c4-2">4.2. Proofs of there exist statements</a></li>
                    <li><a href="#c4-3">4.3. Existence and uniqueness</a></li>
                </ul>
            </li>
            <li class="chapter">
                <a href="#c5">Chapter 5: Sets</a>
                <ul>
                    <li><a href="#c5-0">5.0. Type</a></li>
                    <li><a href="#c5-1">5.1. Union</a></li>
                    <li><a href="#c5-2">5.2. Intersection</a></li>
                    <li><a href="#c5-3">5.2. Intersection</a></li>
                    <li><a href="#c5-4">5.4. Set equality</a></li>
                    <li><a href="#c5-5">5.5. Set Difference</a></li>
                    <li><a href="#c5-6">5.6. Sets of sets</a></li>
                </ul>
            </li>
            <li class="chapter"><a href="#c6">Chapter 6: Proofs by Induction</a></li>
            <li class="chapter"><a href="#c7">Chapter 7: Relations</a></li>
            <li class="chapter"><a href="#c8">Chapter 8: Congruences</a></li>
            <li class="chapter"><a href="#c9">Chapter 9: Functions</a></li>
            <li class="chapter"><a href="#c10">Chapter 10: Cardinality</a></li>
            <li class="chapter"><a href="#c11">Chapter 11: Dependent Type Theory</a></li>
        </ul>
        <button id="expand-all">Open All</button>
        <button id="collapse-all">Close All</button>
    </nav>
    <main>
        <section id="c1">
            <h2>Chapter 1: Preliminaries</h2>
            <section id="c1-0"></section>
            <h3>1.0. Introduction to Lean 4 - Interactive Proof Assistant</h3>
<p>Congratulations on taking your first step toward writing formal mathematical proofs!</p>
<p>When I was taking this course and doing the homework, I was always wondering:
is there a way to verify the proofs I wrote before turning them in? 
Just like using a calculator to check the derivatives and integrals I took in those calculus problems?</p>
<p>If you have the same question, then you are in the right place!
Our amazing mathematicians and computer scientists have developed some useful software tools to construct and verify formal mathematical proofs,
which we typically call the <strong>proof assistants</strong>,
and the tool we are gonna use is called the <strong>Lean Theorem Prover</strong>,
which acts as both a programming language and an interactive proof assistant.
</p>
            <h4>1.0.1. Installing Lean 4</h4>
<p>The version of the Lean theorem prover we will be using is <strong>Lean 4</strong>.
Follow the instructions <a href="https://leanprover-community.github.io/get_started.html"> here</a> 
to install Lean 4 and VS Code editor on your computer.
Then follow the instruction <a href="https://github.com/StevennZZZ/FormalizingMATH300"> here</a> to get a copy of this project on your computer.
</p>
<p>Now we are all set. Open the file named "c1.lean" in VS Code.
Take a look at the contents of this file. 
Suddenly, you are able to figure out everything in this file!</p> ...... well, that's not true.
You might be wondering: what the heck do all these lines of codes mean??
Don't worry, in this chapter, we will go through every line of code in this file,
and by the end of this chapter, you will be able to understand everything in it!
</p>
            <h4>1.0.2. How to use this guide</h4>
<p>
Everything in this guide exactly follows the order of the MATH 300 textbook 
by Conroy-Taggart: An Introduction to Mathematical Reasoning.
For each chapter, we will go over the concepts, theorems, and proofs mentioned in the textbook,
<em>with their implementations in Lean</em>, and we've made a lean file for each chapter
that contains the codes in this guide,
so that you can read this guide while checking the codes in Lean interactively.
</p>
<p>Now is the time to let you know what we are going to do:
we will turn the proofs we wrote into Lean code,
and Lean, as a theorem prover, will produce feedbacks to our inputs
(i.e., the remaining goals we need to solve in order to complete the proof).
Keep in mind that Lean is not a forgiving language. 
Whenever we make a mistake in our proof, whether it's a logical mistake or just a syntax mistake,
Lean will throw an error immediately (since it's interactive), 
and we must stop and fix that error in order to make further progress.
You might get frustrated very often during this learning process,
but remember, this is also the biggest advantage of Lean: 
we can be sure that
the mathematical proofs we construct are absolutely correct.
</p>
<p>
And as you get used to it, Lean can not only verify the proofs you wrote,
but also assist you to construct your own proofs! 
In this guide, we will first walk you through how the proofs in the textbook are exactly implemented in Lean,
which means that we will simply turn the "paper version" of a proof to its "Lean code version".
However, as we are familiar enough with Lean,
I will show you how Lean Prover can do something that's impossible to do on paper.
For example, a statement that requires a <strong>page-long</strong> proof which takes you <strong>hours</strong> just for finding the supporting theorems
can be achieved by a <strong>single command</strong> in Lean!!
I'm sure you will never regret learning this skill in your academic and career life :)
</p>
<p>Get ready? Then let's start!</p>
<section id="c1-1"></section>
            <h3>1.1. Elementary properties of the integers</h3>
<dfn><div class="box">Review:</div></dfn>
<ul>
    <li><strong><em>statement - </em></strong> a sentence that is either true or false</li>
    <li><strong><em>proof - </em></strong> a piece of writing that demonstrates that a particular statement is true</li>
    <li><strong><em>proposition / theorem - </em></strong> a statement that we prove to be true</li>
    <li><strong><em>axiom - </em></strong> a statement that we assume without proof</li>
    <li><strong><em>notations for some common sets of numbers- </em></strong> <br>
        ℕ (natural numbers), ℤ (integers), ℚ (rational numbers), ℝ (real numbers)</li>
</ul>
<dfn><div class="box">In Lean:</div></dfn>
<p>Open the file for this chapter (c1.lean). In VS Code, it's easy to <strong>evaluate</strong> the truth value of a simple mathematical statement 
by using the <code class="single_command">#eval</code> command. 
Move you cursor over the <code class="single_command">#eval</code> command,
and in the pop-up window, you can see how Lean evaluates this statement.
</p>
<pre><code class="snippet"><div class="comment">--1.1.01</div>
#eval 1 + 1 = 2
#eval 1 + 1 = 3
#eval 2^10 < 2000
#eval 500 * 20 + 1356^2 - 63794 ≥ 10000
</code></pre>
<p>
For most of the time, we use Lean to construct formal proofs,
instead of just checking if 1 + 1 = 2.
In Lean 4 (and for all the exercise problems in this guide), 
a proof typically has the following structure:
</p>
<pre><code class="snippet"><div class="comment">--1.1.02</div>
example {n : ℝ} (h1 : n = 1) : n + 1 = 2 := by
  rw [h1]
  norm_num
</code></pre>
<p>Yes, this is a complete mathematical proof in Lean. 
In this case, it has three lines.
By looking at the first line of code, can you guess what it's trying to prove?
</p>
<p>Here is the interpretation: Let n be a real number.
If n = 1, then n + 1 = 2. Is your guess correct?
The first line of a Lean proof always indicates the statement we are trying to prove,
so let's go through it first.
</p>
<em><strong>First Line: </strong></em>
<code class="snippet">example {n : ℝ} (h1 : n = 1) : n + 1 = 2 := by</code>
<p><code class="snippet">example</code> means this problem is just an example. 
Nothing fancy here.</p>
<p><code class="snippet">{n : ℝ}</code> means "Let n be a real number".
Many mathematical theorems make use of variables, 
which we need to put at the very beginning. You can have as many variables as you want,
like <code class="snippet">{a b c : ℤ}</code> simply means "Suppose a, b, and c are integers".
</p>
<p><code class="snippet">(h1 : n = 1)</code> sets up the hypothesis.
It's the thing we assume to be true before making our statement. 
Here, "h1" is just the name we give to the hypothesis, 
and "n = 1" is the thing we assume: if n = 1.
Again, you can have as many hypotheses as you want.
Just make sure all the variables you use are already declared in the previous part.
</p>
<p>The variable declarations and hypotheses,
together with the axioms we already know,
are called the <strong>assumptions</strong>.
After all the assumptions comes the colon <code class="snippet">:</code>,
which acts as a boundary line between the <strong>assumptions</strong> we make 
and the <strong>goal</strong> we are trying to solve.
There are, of course, some theorems that have no explicit assumptions in the first place,
which you can simply put a colon after "example": <code class="snippet">example :</code>
</p>
<code class="snippet">n + 1 = 2</code> states the goal of the proof.
In this case, our goal is to prove that "n + 1 = 2".
</p>
</p><code class="snippet">:= by</code> just literally means
"we will prove it by", 
which marks both the end of the statement and the start of the proof.
<p>Whoa! That's all the information in the first line of code.
In VS Code, if you click the end of the first line,
in the "Lean infoview" window, you should see our hypotheses (before ⊢) and goal (after ⊢) listed in order.
This window shows the <strong>current proof state</strong> of this example.
If you click the end of other lines,
you can see that the proof state changes accordingly,
which shows the progress that line of code makes to the proof.
At the last line it shows "no goals",
which means that we have completed our proof.
You can see why it's called the "interactive theorem prover".</p>
<p>
Alright! Look back to the first line again, can you understand everything now?
If so, let's dive into the exciting part: prove it!
</p>
<em><strong>Second Line: </strong></em>
<code class="snippet">rw [h1]</code>
<br>
<em><strong>Third Line: </strong></em>
<code class="snippet">norm_num</code>
<p>
Before looking at code, think about it:
how you might prove this theorem: 
Let n be a real number. If n = 1, then n + 1 = 2. 
</p>
<p>
Well, you might be thinking: 
do I really need to prove this thing?
Even an elementary school student can figure this out just in mind!
But here is the thing:
in proof-writing (and also in programming),
we need to demonstrate the logical order exactly.
We need to break the entire process into single steps 
and put them in sequence.
This is especially important when we are using the theorem prover
because the things we find to be obvious might make no sense to the computer at all!
We have to show exactly how we solve the problem step by step.
</p>
<p>
So let's slow down a little bit and think: 
what's the logical order of our thinking.
Well, we know n = 1 from the assumption, 
so we can <strong>rewrite</strong> n as 1.
And if we <strong>normalize</strong> 1 + 1,
we get 2, thus we prove the theorem.
These are exactly what 
<code class="single_command">rw</code>
and <code class="single_command">norm_num</code>
commands do.
</p>
<p>
<code class="snippet">rw [h1]</code> means to rewrite the goal based on h1.
In this case the argument we give to rw is "h1", 
which is "n = 1", 
so it will replace all the "n"s in the goal with "1"s.
Therefore, if you click the end of the line,
in Lean Infoview window,
you can see that the goal changes from "n + 1 = 2" to "1 + 1 = 2".
Be careful about the syntax: 
you always need to put arguments inside the square brackets.
</p>
<p>OK, so how to prove "1 + 1 = 2"?
We know that it's based on the axioms of algebra.
As in the examples above, Lean is able to evaluate the calculation results,
so whenever we see that our goal only involve simple numerical expressions,
we can let Lean normalize them and prove the goal for us.
</p>
<code class="snippet">norm_num</code> closes the goal with only numerical expressions.
In this case, the goal is "1 + 1 = 2",
so <code class="snippet">norm_num</code> closes the goal immediately.
Now we have no goals left in the current proof state.
We completed our proof!
</p>
            <h4>A few more examples:</h4>
<pre><code class="snippet"><div class="comment">--1.1.03</div>
example {a b : ℤ} (h1 : a = 2) (h2 : b = 5) : a + b = 7 := by
  rw [h1, h2]
  norm_num
</code></pre>
<p>
Don't look at the next part! Try to figure out what statement it's trying to prove by yourself!
You can do it :)
</p>
<p>
Now I assume that you can understand this example. Well, our hypotheses are "a = 2" and "b = 5", and our goal is "a + b = 7".
The way to prove it is basically the same as in the last example: 
we use <code class="single_command">rw</code> to replace the variables with their corresponding numbers based on the hypotheses,
and use <code class="single_command">norm_num</code> to do the algebra with only numbers.
In this case, we need to rewrite two variables. 
You can use <code class="single_command">rw</code> commands twice,
but you can also put the hypotheses you use for rewriting in the same command and seperate them with commas,
as what we did in this example: <code class="single_command">rw [h1, h2]</code>.
</p>
    <p>One more example before we move on:</p>
<pre><code class="snippet"><div class="comment">--1.1.04</div>
example {n : ℝ} (h1 : 1 = n) : n + 1 = 2 := by
  rw [← h1]
  norm_num  
</code></pre>
<p>
It's the same as the first example, except that the hypothesis is "1 = n" instead of "n = 1".
If we want to <strong>rewrite</strong> the n in our goal as 1,
we need to tell the <code class="single_command">rw</code> command explicitly that 
we want to replace n with 1 instead of replacing 1 with n (which it does by default). 
Therefore, we need to put a "←" before the hypothesis: <code class="single_command">rw [← h1]</code>.
Type "\l" in VS Code to get "←".
</p>
<dfn><div class="box">Remarks:</div></dfn>
<ol>
<li>
We were implementing what's called the "tactic-style" proof.
In the example above, both <code class="single_command">rw</code>
and <code class="single_command">norm_num</code>
are "tactics" (and they are two of the most common tactics we will be using).
As we go further, 
we will need to use more and more tactics to achieve different kinds of goals.
</li>
<li>
If you've taken CSE121 or some other programming courses,
you instructor might empahsized a lot about "coding style".
We will not focus on that too much, 
but it's definitely a good idea to structure you codes in a clean way.
As in this example, you see that we indent a block of codes that solves a specific goal,
and we use only one tactic for each line.
</li>
<li>
You might have noticed that the assumptions can be enclosed by either parentheses () or curly braces {}.
There is a subtle difference between these two, which we will talk about in chapter 3.
For now, we don't need to worry about the difference.
</li>
<li>
I just realize that the subtitle of this section is "Elementary properties of the integers",
but I didn't mention anything about that big table on page 9 of your textbook at all.
Well, we will go over how those properties are implemented in Lean 4 in this chapter,
but I need to introduce something else before that.
</li>
</ol>
<section id="c1-2"></section>
            <h3>1.2. Definitions</h3>
<dfn><div class="box">Review:</div></dfn>
<ur>
<li>
<em><strong>definition - </strong></em>an agreement between the writer and the reader as to the meaning of a word or phrase
</li>
<li>
<em><strong>absolute value - </strong></em>Let n be an integer. 
We define the absolute value of n to be the integer |n| given by
the multi-part function:
|n| = n if n ≥ 0; |n| = -n if n < 0.
</li>
<li>
<em><strong>divisibility - </strong></em>Suppose a and b are integers. We say that a divides b or that b is divisible by a and
write a | b if there exists an integer c such that b = ac. If there exists no such integer c, then we say
that a does not divide b or that b is not divisible by a and we write a ∤ b.
</li>
<li>
<em><strong>even and odd - </strong></em>An integer a is <strong><em>even</em></strong> if a = 2k for some integer k.
An integer a is <strong><em>odd</em></strong> if a = 2k + 1 for some integer k.
</li>
<li>
<em><strong>parity - </strong></em>Two integers that are either both even or both odd are said to have the <strong><em>same parity</em></strong>.
If one integer is even and the other is odd, then the two have <strong><em>opposite parity</em></strong>.
</li>
</ur>
<p><dfn><div class="box">In Lean: </div></dfn>
Not every mathematical definition is included in Lean 4 by default.
You can, of course, define everything by yourself in Lean 4
(which we might cover later),
but for now let's just use the definitions that others have written
for the sake of time.
We usually need to <strong>import</strong> the definitions we want to the Lean file.
If you have some experience with other programming languages,
you should've seen things like that lot (e.g. "import java.util.*" in Java, "import numpy as np" in Python).
But to Lean 4, where should import things from?
</p>
            <h4>1.2.0. Mathlib</h4>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib">Mathlib</a> 
is a super powerful library for Lean 4 that includes all the definitions, theorems, and tactics we need for this course.
Since we will only deal with real numbers (and mostly with integers),
we only need to import a small portion of this giant library,
which is "Mathlib.Data.Real.Basic". 
This is what the first line of code mean:
 (you should always put the libaries you want to import at the beginning of the file)
</p>
<p>
<code class="snippet">import Mathlib.Data.Real.Basic</code>
</p>
<p>
Now we have all the definitions we need!
</p>
<p>
In Lean 4, you can use |a| ("shift + \" for |) to represent the absolute value of "a" directly.
Below is an example of proving that the absolute value of -7 is 7.
Since the goal consists of only numerical expressions,
you can use <code class="single_command">norm_num</code> to prove it.
</p>
<pre><code class="snippet"><div class="comment">--1.2.01</div>
example : |-7| = 7 := by
  norm_num
</code></pre>
<p>
To show that a divides b in Lean 4, you need to type "a ∣ b".
("\ + |" for "∣" in VS Code).
By the way, if you wonder how to get some special symbols in VS Code
("\real" for ℝ, "\nat" for ℕ, etc.), 
just find some examples with those symbols in the file, 
hover you cursor over the symbols,
and a pop-up window well shows you how to type those symbols.
</p>
<p>Below is an example that shows how to prove "3 divides 6"</p>
<pre><code class="snippet"><div class="comment">--1.2.02</div>
example : 3 ∣ 6 := by
  use 2
</code></pre>
<p>
Oops! Here comes a new tactic - "use". 
Let's review the definition of divisibility: 
Suppose a and b are integers.
a | b if <em>there exists</em> an integer c such that b = ac.
In this case, 3 divides 6 because <em>there exists</em> an integer c such that 6 = 3 * c.
It's obvious that we need to <strong>use</strong> 2 for c in order to prove it,
which is what the tactic <code class="single_command">use</code> does.
</p>
<p>
The biggest takeaway here is that we can use the <code class="single_command">use</code> tactic 
to prove anything with a definition that includes phrases like "there exists" or "for some",
since we <strong>use</strong> a specific number to show that there really <strong>exists</strong> a number that satisfies the definition.
You might get confused about what I actually mean by it here. Don't worry!
It's a concept from the next chapter: quantifier.
We will talk more about it later.
</p>
In Lean 4, you can directly express "a is an odd number" as <code class="single_command">Odd a</code>,
or "b is an even number" as <code class="single_command">Even b</code>. Very simple.
Below is a proof of the statement that "20 is an even number":
<pre><code class="snippet"><div class="comment">--1.2.03</div>
example : Even 20 := by
  use 10
</code></pre>
An integer a is even if a = 2k for some integer k. 
Again, this definition includes the phrase "for some", 
so we need the <code class="single_command">use</code> tactic to give the specific integer that satisfies the definition.
Here, to prove that 20 is an even number,
we need to show that 20 = 2 * k for some integer k.
Clearly, k = 10, so we <code class="single_command">use 10</code>.
<section id="c1-3"></section>
            <h3>1.3. Elementary properties of the integers (again)</h3>
<p>Now it's time to go back to the table on page 9 of the textbook: Elementary Properties of the Integers (EPIs).</p>
<p>
As we have imported a lot of theorems from Mathlib, 
let's see which Lean 4 command each theorem corresponds to (you don't need to understand everything for now):
</p>
<p>
Suppose a, b, c, and d are integers.
</p>
<ol>
<!--1-->
<li>
<em><strong>Closure:</strong></em> a + b and ab are integers.<br>
In Lean: Good news: You don't have to specify this property in Lean.
</li>
<!--2-->
<li>
<em><strong>Substitution of Equals:</strong></em> If a = b, then a + c = b + c and ac = bc.<br>
In Lean: <code class="single_command">congr</code> <br>*
(This is a tactic. Don't use <code class="single_command">exact</code> for this one.)
</li>
<!--3-->
<li>
<em><strong>Commutativity: </strong></em>a + b = b + a and ab = ba.<br>
In Lean: <code class="single_command">add_comm a b</code> for addition, 
<code class="single_command">mul_comm a b</code> for multiplication.
</li>
<!--4-->
<li>
<em><strong>Associativity: </strong></em>(a + b) + c = a + (b + c) and (ab)c = a(bc).<br>
In Lean: <code class="single_command">add_assoc a b c</code> for addition, 
<code class="single_command">mul_assoc a b c</code> for multiplication.
</li>
<!--5-->
<li>
<em><strong>The Distributive Law: </strong></em>a(b + c) = ab + ac<br>
In Lean: <code class="single_command">mul_add a b c</code>
</li>
<!--6-->
<li>
<em><strong>Identities: </strong></em>a + 0 = 0 + a = a and a · 1 = 1 · a = a.<br>
(0 is called the <em>additive identity)</em>.<br> (1 is called the <em>multiplicative identity)</em>. <br>
In Lean:<br> 
a + 0 = a: <code class="single_command">add_zero a</code><br>
0 + a = a: <code class="single_command">zero_add a</code><br>
a · 1 = a: <code class="single_command">mul_one a</code><br>
1 · a = a: <code class="single_command">one_mul a</code>
</li>
<!--7-->
<li>
<em><strong>Additive Inverses: </strong></em>There exists an integer −a such that a + (−a) = (−a) + a = 0.<br>
In Lean: <br>
a + (-a) = 0: <code class="single_command">add_right_neg a</code><br>
(-a) + a = 0: <code class="single_command">add_left_neg a</code>
</li>
<!--8-->
<li>
<em><strong>Trichotomy: </strong></em>Exactly one of the following is true: a > 0, −a > 0, or a = 0.<br>
In Lean: lt_trichotomy a 0
</li>
<!--9-->
<li>
<em><strong>The Well-Ordering Principle: </strong></em>Every non-empty set of positive integers contains a smallest ele-
ment.<br>
In Lean: we will discuss about this property when we work on "cardinality". (chapter 10)
</li>
<!--10-->
<li>
a ·0 = 0<br>
In Lean: <code class="single_command">mul_zero a</code>
</li>
<!--11-->
<li>
If a + c = b + c, then a = b.<br>
In Lean: <code class="single_command">add_right_cancel h</code>,
with <code class="single_command">(h : a + c = b + c)</code>
</li>
<!--12-->
<li>
−a = (−1) · a <br>
In Lean: <code class="single_command">neg_eq_neg_one_mul a</code>
</li>
<!--13-->
<li>
(−a) · b = −(ab) <br>
In Lean: <code class="single_command">neg_mul a b</code>
</li>
<!--14-->
<li>
(−a) · (−b) = ab <br>
In Lean: <code class="single_command">neg_mul_neg a b</code>
</li>
<!--15-->
<li>
If ab = 0, then a = 0 or b = 0. <br>
In Lean: <code class="single_command">mul_eq_zero.1 h</code>, 
with <code class="single_command">(h : a * b = 0)</code>
</li>
<!--16-->
<li>
If a ≤ b and b ≤ a, then a = b. <br>
In Lean: <code class="single_command">le_antisymm h1 h2</code>,
with <code class="single_command">(h1 : a ≤ b) (h2: b ≤ a)</code>
</li>
<!--17-->
<li>
If a < b and b < c, then a < c. <br>
In Lean: <code class="single_command">lt_trans h1 h2</code>,
with <code class="single_command">(h1 : a < b) (h2: b < c)</code><br>
If a ≤ b and b ≤ c, then a ≤ c. <br>
In Lean: <code class="single_command">le_trans h1 h2</code>,
with <code class="single_command">(h1 : a ≤ b) (h2: b ≤ c)</code>
</li>
<!--18-->
<li>
If a < b, then a + c < b + c. <br>
In Lean: <code class="single_command">add_lt_add_right h c</code>,
with <code class="single_command">(h : a < b)</code><br>
If a ≤ b, then a + c ≤ b + c. <br>
In Lean: <code class="single_command">add_le_add_right h c</code>,
with <code class="single_command">(h : a ≤ b)</code>
</li>
<!--19-->
<li>
If a < b and 0 < c, then ac < bc. <br>
In Lean: <code class="single_command">mul_lt_mul_of_pos_right h1 h2</code>,
with <code class="single_command">(h1 : a < b) (h2 : 0 < c)</code><br>
If a ≤ b and 0 ≤ c, then ac ≤ bc. <br>
In Lean: <code class="single_command">mul_le_mul_of_nonneg_right h1 h2</code>,
with <code class="single_command">(h1 : a ≤ b) (h2 : 0 ≤ c)</code>
</li>
<!--20-->
<li>
If a < b and c < 0, then bc < ac. <br>
In Lean: <code class="single_command">mul_lt_mul_of_neg_right h1 h2</code>,
with <code class="single_command">(h1 : a < b) (h2 : c < 0)</code><br>
If a ≤ b and c ≤ 0, then bc ≤ ac. <br>
In Lean: <code class="single_command">mul_le_mul_of_nonpos_right h1 h2</code>,
with <code class="single_command">(h1 : a ≤ b) (h2 : c ≤ 0)</code>
</li>
<!--21-->
<li>
If a < b and c < d, then a + c < b + d. <br>
In Lean: <code class="single_command">add_lt_add h1 h2</code>,
with <code class="single_command">(h1 : a < b) (h2 : c < d)</code><br>
If a ≤ b and c ≤ d, then a + c ≤ b + d. <br>
In Lean: <code class="single_command">add_le_add h1 h2</code>,
with <code class="single_command">(h1 : a ≤ b) (h2 : c ≤ d)</code>
</li>
<!--22-->
<li>
If 0 ≤ a < b and 0 ≤ c < d, then ac < bd. <br>
In Lean: <code class="single_command">mul_lt_mul'' h1 h2 h3 h4</code>,
with <code class="single_command">(h1 : a < b) (h2 : c < d) (h3 : 0 ≤ a)  (h4 : 0 ≤ c)</code><br>
If 0 ≤ a ≤ b and 0 ≤ c ≤ d, then ac ≤ bd. <br>
In Lean: <code class="single_command">mul_le_mul h1 h2 h3 h4</code>,
with <code class="single_command">(h1 : a ≤ b) (h2 : c ≤ d) (h3 : 0 ≤ c)  (h4 : 0 ≤ b) </code>
</li>
<!--23-->
<li>
If a < b, then −b < −a. <br>
In Lean: <code class="single_command">neg_lt_neg h</code>,
with <code class="single_command">(h : a < b)</code><br>
If a ≤ b, then −b ≤ −a. <br>
In Lean: <code class="single_command">neg_le_neg h</code>,
with <code class="single_command">(h : a ≤ b)</code>
</li>
<!--24-->
<li>
0 ≤ a^2, where a^2 = a · a. <br>
In Lean: <br>
<code class="single_command">sq_nonneg a</code> for (0 ≤ a^2)<br>
<code class="single_command">sr a</code> for (a^2 = a * a)
</li>
<!--25-->
<li>
If ab = 1, then either a = b = 1 or a = b = −1. <br>
In Lean: <code class="single_command">Int.mul_eq_one_iff_eq_one_or_neg_one.1 h</code>,
with <code class="single_command">(h : a * b = 1)</code> <br>
*You need to import "Mathlib.Data.Int.Units" in order to use this command.
</li>
</ol>
<dfn><div class="box">Remarks:</div></dfn>
<p>Alright, alright, I know what you wanna say: what the heeeeeeeck are all these things? That's too much!!!!!</p>
<p>Well, as you are provided with this table in your homework and exams,
you are also not required to memorize every command:
just refer back to it whenever needed.
And in fact, we will probably use this table of commands <strong>only for this chapter</strong>!
In the next few chapters, we will let you know some other useful Lean tactics that can handle these properties <strong>all at once</strong>.
At that time, you will see how powerful the Lean Theorem Prover is for assisting your proving.
But for now let's use the commands from this table just for practice.
</p>
<p>
And now you may have a new question:
OK, so now I know all the commands of these theorems, but how to use them? For example:
If you are asked to prove that a + b = b + a, where a and b are integers.
How do you prove it?
</p>
<p>
You stare it for a while and suddenly realize: it's in the EPIs table!
So you grab that table and find that the goal of your proof is 
<strong>exactly</strong> the third property: commutativity,
so you need to use the <code class="single_command">exact</code> tactic.
This is the fourth tactic we learn in this chapter:
</p>
<pre><code class="snippet"><div class="comment">--1.3.01</div>
example {a b : ℤ} : a + b = b + a := by
  exact add_comm a b
</code></pre>
<p>
That's it! Each time you find your goal to be <strong>exactly</strong> the same as a theorem in the EPIs table,
you use <code class="single_command">exact</code> tactic, 
and copy and paste the command of that property after <code class="single_command">exact</code> .
</p>
<p>
Here is another example:
</p>
<pre><code class="snippet"><div class="comment">--1.3.02</div>
example {a b : ℤ} (h : a < b) : a + 5 < b + 5 := by
  exact add_lt_add_right h 5
</code></pre>
<p>
(Hint: it's the 18th property.)
</p>
<p>
Since <code class="single_command">exact</code> tactic can be used for anything we already know,
it can not only be be used for the EPIs table's theorems,
but also for the assumption that is the same as the goal.
As a silly example: suppose a is an integer, prove that if a = 1, then a = 1.
</p>
<pre><code class="snippet"><div class="comment">--1.3.03</div>
example {a : ℤ} (h : a = 1) : a = 1 := by
  exact h
</code></pre>
<p>
Well, the goal is <strong>exactly</strong> the same as the hypothesis, 
so you can use <code class="single_command">exact</code> here.
</p>
<p>
One last thing before we see a more difficult example and end this chapter:
<code class="single_command">exact</code> is not the only tactic we can use for citing properties from the EPIs table.
If the property states something about "equality", 
then we can also <strong>rewrite</strong> part of the expression to the other side of the equality using your favorite <code class="single_command">rw</code> tactic.
Let's see an example:
</p>
<pre><code class="snippet"><div class="comment">--1.3.04 </div>
example {a b : ℤ} (h : a + c = b + 0) : a + c = b := by
  rw [add_zero b] at h
  exact h
</code></pre>
<p>
Note that you cannot use <code class="single_command">exact</code> directly
because we are not proving "b + 0 = b" here. We are proving something else
but need to use the fact that "b + 0 = b", which is the 6th property,
so the best way we can do is to <strong>rewrite</strong> "b + 0" in the hypothesis h to "b".
Last time we only use <code class="single_command">rw</code> to change the goal.
If you want to change the hypothesis you need to add <code class="single_command">at h</code> after the command,
where "h" is the hypothesis you want to change.
<code class="single_command">add_zero b</code> gives the fact that "b + 0 = b",
so <code class="single_command">rw [add_zero b] at h</code>
searches for "b + 0" in the hypothesis h and replaces it with "b".
Now the hypothesis h is the same as the goal, so we can use <code class="single_command">exact h</code> to close the goal.
</p>
            <h4>1.3.1 Example</h4>
<p>
Perfect! With everything we learned so far,
let's try to prove <strong>Example 1.2.</strong> from the textbook (page 10) :
If a,b and c are integers, and c = a + b, then a = c − b.
</p>
<pre><code class="snippet"><div class="comment">--1.3.1.01 (incomplete)</div>
example {a b c : ℤ} (h : c = a + b) : a = c - b := by
  <span class="sorry">sorry</span>
</code></pre>
<p>We have set the problem but haven't started our tactic-style proof yet.
However, if you click the end of the second line (after "sorry"), 
you will see, in the current goal state, that there are "no goals" left.
I am <strong>sorry</strong> to confuse you,
but this is what the <code class="single_command">sorry</code> tactic does:
it closes the current goal immediately.
Just like cheating in video games,
you didn't prove anything, but you close the goal.
People use this tactic for temporarily incomplete proof, 
which they will later delete the <code class="single_command">sorry</code> and finish the proof.
So...let's delete it. Below is the complete proof. 
Note that all the steps are exactly the same as the proof in the textbook.
</p>
<p>
Friendly Reminder: you might see a couple of commands that we haven't yet learned about.
Feel free to Google Lean 4's documentations (or simply move your cursor over the commands in VS code) to see how they work.
That being said, it might take you a while to understand everything in this proof,
and you are not required to do so, as we will cover them in the next few chapters.
</p>
<pre><code class="snippet"><div class="comment">--1.3.1.01 (complete)</div>
example {a b c : ℤ} (h : c = a + b) : a = c - b := by
<span class="comment">  -- Substitution of Equals</span>
  have h1 : c + (-b) = (a + b) + (-b) := by
    congr
<span class="comment">  -- Associativity of Addition </span>
  have h2 : c + (-b) = a + (b + (-b)) := by
    rw [add_assoc a b (-b)] at h1
    exact h1
<span class="comment">  -- Additive Inverses </span>
  have h3 : c + (-b) = a + 0 := by
    rw [add_right_neg b] at h2
    exact h2
<span class="comment">  -- Additive Identity </span>
  have h4 : c + (-b) = a := by
    rw [add_zero a] at h3
    exact h3
<span class="comment">  -- Symmetry of equality </span>
  have h5 : a = c + (-b) := by
    symm at h4
    exact h4
  exact h5
</code></pre>
<dfn><div class="box">Remarks:</div></dfn>
<p>
<ol>
<li><code class="single_command">have hn : t</code>
adds <code class="single_command">(hn : t)</code> to the assumptions.
But since this assumption "t" is not part of the original assumptions,
you need to prove it in order to use it, which is why it follows by <code class="single_command">:= by</code>.
the block of code indented after it will be used to solve the subgoal "t".
</li>
<li>
If you type <span class="comment">  -- </span> somewhere at a line,
everything following will be the "comment", 
which will be ignored by the computer.
Use <code class="single_command">have</code> and comments
can make your code much more readable.
</li>
<li>
<code class="single_command">congr</code> is a tactic, not a theorem.
Whenever you have "a = b" as one assumption and "a + c = b + c" as the goal,
just type <code class="single_command">congr</code> directly to close the goal.
(This tactic is actually much more powerful than that, 
but for now let's just use it for this specific property of integers.)
</li>
<li>
The third to last line of code uses the tactic <code class="single_command">symm</code>,
which switches two sides of the equation.
</li>
</ol>
</p>
<p>
You made it! Congratulations on reading through the first chapter.
Since now you have a basic idea of how Lean Theorem Prover works,
we can try something much more interesting in the following chapters :D
</p>

        </section>
    
        <section>
            <section id="c2">
            <h2>Chapter 2: Logic and mathematical language</h2>
<dfn><div class="box">Review:</div></dfn>
<p></p>
<strong><em>statement - </em></strong> a sentence that is either true or false
<p>
We can use propositional variables (P, Q, R, ...) to indicate some arbitrary statements, 
like "P is true", "Q is false", blah blah...
</p>
<p>
When talking about a statement,
we often want to know all the possibilities of the truth value that statement can have,
and we can use a <strong>truth table</strong> to list those possibilities:
</p>
<table>
    <tr>
      <th>P</th>
    </tr>
    <tr>
      <td>True</td>
    </tr>
    <tr>
      <td>False</td>
    </tr>
  </table>
<p>
Well, the truth value of a statement with one variable can only have two possibilities,
which is not very interesting.
However, as Mathematics is the art of <em>relations</em>,
things get more interesting when we study a statement that consists of more than one variable using <strong>logical connectives</strong>.
</p>
<section id="c2-1"></section>
            <h3>2.1. Negations (¬)</h3>
<dfn><div class="box">Review:</div></dfn>
<p>
The negation operator negates the truth value of a statement. 
False becomes true, and true becomes false. Thus:
</p>
<table>
    <tr>
        <th>P</th>
        <th>¬P</th>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
    </tr>
</table>
<p></p>
<dfn><div class="box">In Lean:</div></dfn>
<p>In VS Code, type "\not" to get the operator "¬".
(There are of course other ways for doing so. 
You can always check the ways to type specific symbols by hovering your cursor over them.)
</p>
<p>
Try to evaluate the following. See the difference?
</p>
<pre><code class="snippet"><div class="comment">-- 2.1.01</div>
#eval 10 > 5
#eval ¬(10 > 5)
</code></pre>
<dfn><div class="box">Remarks:</div></dfn>
<p>We can actually keep negating the truth value of a statement:</p>
<table>
    <tr>
        <th>P</th>
        <th>¬P</th>
        <th>¬¬P</th>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>False</td>
    </tr>
</table>
<p>
We can see that the "double negation" restores the original truth value.
</p>
<section id="c2-2"></section>
            <h3>2.2. And (∧) and Or (∨) / Conjunction and Disjunction</h3>
<dfn><div class="box">Review:</div></dfn>
<ul>
    <li>The statement P <strong>and</strong> Q (P ∧ Q) is true provided P is true and Q is true. Otherwise, P and Q is false.</li>
    <li>The statement P <strong>or</strong> Q (P ∨ Q) is true provided P is true, Q is true, or both are true. Otherwise, P or Q is false.</li>
</ul>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>P ∧ Q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>False</td>
    </tr>
</table>
<p></p>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>P ∨ Q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>False</td>
    </tr>
</table>
<p>
The truth tables for "And" operator and "Or" operator get bigger. 
Because now we have <em>two</em> variables in a statement,
we have <em>four</em> possibilities in total, as shown above.
You can see the pattern here:
Each time we add a variable to our statement, we double the combinations.
Therefore, a statement with <strong>n</strong> propositional variables has <strong>2^n</strong> combinations.
</p>
<dfn><div class="box">In Lean:</div></dfn>
<p>
In VS Code, type "\and" for "∧" and type "\or" for "∨".
Try evaluating the following statements.
</p>
<pre><code class="snippet"><div class="comment">-- 2.2.01</div>
#eval (1 + 1 = 2) ∧ (2 = 0)
#eval (1 + 1 = 2) ∨ (2 = 0)
</code></pre>
<p>
The first statement (1 + 1 = 2) is true, and the second statement (2 = 0) is false. 
This situation corresponds to the second row of the truth table: P is true while Q is false.
Therefore, (P ∧ Q) is false, and (P ∨ Q) is true, according to the truth tables.
</p>
<p>
OK. We've discussed a lot about the class materials.
Now let's see how to prove things with these logical connectives in Lean 4.
</p>
<Strong><em>First situation: the goal includes "and" </em></Strong>.
<p>
Let's take a look at the truth table of (P ∧ Q).
We can see that the only situation for (P ∧ Q) to be true is that P and Q should both be true.
</p>

</p>
Therefore, in order to prove that (P ∧ Q) is true, we need to prove that P is true and Q is true,
which means we actually have two goals to prove: (P is true) (Q is true).
In Lean 4, we need to manually <strong>construct</strong> these two goals using the <code class="single_command">constructor</code> tactic. 
</p>
<pre><code class="snippet"><div class="comment">-- 2.2.02</div>
example {P Q : Prop} (hp : P) (hq : Q) : P ∧ Q := by
  constructor
    · exact hp
    · exact hq
</code></pre>
<p>
Here, we define P and Q to be propositional variables by typing <code class="single_command">{P Q : Prop}</code>. 
And we have two assumptions: 
<code class="single_command">(hp : P)</code> is the hypothesis that P is true, and 
<code class="single_command">(hq : Q)</code> is the hypothesis that Q is true.
Our goal is to prove that <code class="single_command">P ∧ Q</code> is true.
</p>
<p>
We first use the <code class="single_command">constructor</code> tactic to split our goal to two subgoals:
<code class="single_command">⊢ P</code> and <code class="single_command">⊢ Q</code>.
If you click the end of this line and look at the Lean Infoview window in your VS Code editor,
you can see that now we have two goals to solve.
</p>
<p>
For each of the goal, it's <strong>exactly</strong> the same as one of the hypothesis,
so as usual, we can use the <code class="single_command">exact</code> tactic to solve it.
Once we close all the goals, we complete our proof.
</p>
<p>
Note that we use a dot <code class="single_command">·</code> for the lines of codes that solves a specific goal.
It is also a tactic! 
If you have multiple goals, the <code class="single_command">·</code> tactic will let the proof state only show the main goal you need to prove at that time.
It can not only help you focus on a specific subgoal at one time, but also make the code more structured.
Keep in mind that all the lines of code for one goal should be indented for the same amount of spaces (they need to be left-aligned).
</p>
<strong><em>Second Situation: the goal includes "or"</em></strong>
<p>
Look at the truth table of (P ∨ Q). 
You can see that it's much easier to prove that (P ∨ Q) is true:
as long as one of the variable is true, the entire statement is true.
</p>
<p>
In other words, to prove that (P ∨ Q) is true, we can just show that (P is true).
Similarly, we can just show that (Q is true). Either works.
</p>
<pre><code class="snippet"><div class="comment">-- 2.2.03</div>
example {P Q : Prop} (h : P) : P ∨ Q := by
  left
  exact h

</code></pre>
<pre><code class="snippet"><div class="comment">-- 2.2.04</div>
example {P Q : Prop} (h : Q) : P ∨ Q := by
  right
  exact h
</code></pre>
<p>
The first example shows how we prove (P ∨ Q) by only using the hypothesis that (P is true),
while the second examples shows how we do that by only using (Q is true).
If the goal has the "Or" operator "∨",
we use the <code class="single_command">left</code> tactic to tell Lean that we only want to prove the <strong>left</strong> side of the goal,
so it reduces the goal from (P ∨ Q) to P.
Same thing to the <code class="single_command">right</code> tactic,
which reduces the goal from (P ∨ Q) to Q.
</p>
<strong><em>Third situation: the hypothesis includes "and"</em></strong>
<p>
Well, if we already know that (P ∧ Q) is true, then we know that P and Q should both be true.
Therefore, (P ∧ Q) is a very strong condition: we can use it not only to prove that (P is true), but also to prove that (Q is true).
</p>
<pre><code class="snippet"><div class="comment">-- 2.2.05</div>
example {P Q : Prop} (h : P ∧ Q) : P := by
  cases' h with hp hq
  exact hp
</code></pre>
<p>
In this example, our hypothesis is <code class="single_command">P ∧ Q</code>,
and our goal is <code class="single_command">P</code>. 
To prove it, we need to first split our hypothesis to two new hypotheses,
and we do so by using the <code class="single_command">cases'</code> command.
<code class="single_command">cases' h with hp hq</code>
means to split the hypothesis h to two new hypotheses named hp and hq.
Lean can figure out by itself what the new hypotheses should be.
In this case, the original hypothesis is (P ∧ Q), 
so the new hypotheses should be (P) and (Q).
</p>
<p>
You will see why this tactic is called <code class="single_command">cases'</code> in the next and last situation.
</p>
<strong><em>Fourth situation: the hypothesis includes "or"</em></strong>
<p>
I should say this is the most important situation you need to know since it turns out to be the key idea of "proof by cases",
which we will talk about in the next chapter.
</p>
<p>Think about this question: if you know that (P ∨ Q) is true, 
can you make conclusion that (P is true)? 
Or similarly, can you say that (Q is true)?
</p>
<p>
Boom! You can't :) 
</p>
<p>
If you look at the truth table, you can see that 
"(P ∨ Q) is true" correspond to three combinations: 
(P is true, Q is true) (P is true, Q is false) (P is false, Q is true).
</p>
<p>
Therefore, you can't tell whether one of the variables is true by just knowing (P ∨ Q) is true.
However, there is one thing you can do: you can assume two <strong>cases</strong>.
One case is that you only know P is true, and the other case is that you only know Q is true.
If both of them lead to the same conclusion, then you can say that (P ∨ Q) also leads to that conclusion
because you've considered about all the <strong>cases</strong> the hypothesis (P ∨ Q) can have.
</p>
<p>
I keep emphasizing the word "cases" because you can also use the <code class="single_command">cases'</code> tactic here
(I think that's probably why it's called <code class="single_command">cases'</code>). 
When used for the assumption (P ∧ Q), it splits the hypothesis to two new hypotheses,
and you can use either of them later.
When used for the assumption (P ∨ Q), however, it makes two new goals:
although the two goals are the same, the first goal uses the first hypothesis (P) while the second goal uses the second hypothesis (Q).
You need to prove both of them in order to complete the goal.
</p>
<pre><code class="snippet"><div class="comment">-- 2.2.06</div>
example {P Q : Prop} (h : P ∨ Q) : P ∨ Q := by
  cases' h with hp hq
  · left
    exact hp
  · right
    exact hq
</code></pre>
<p>
You might find this example to be kind of silly: we can just use <code class="single_command">exact h</code> to close the goal.
And...you are right. This example just gives you a sense of how to prove by cases,
which we will spend a lot of time on in chapter 3. 
(This example includes the tactics we discussed in the first two situations.
If you find it hard to understand this example, the first two situations' examples should help)
</p>
            <h4>2.2.1. Negation of <em>"and"</em> and <em>"or"</em> statements (De Morgan's laws)</h4>
<p>
The textbook gives some intuitive examples and then draws the following conclusion:
</p> 
<ul>
<li>
    In general, the statement <em>not (P and Q)</em> has the same meaning as the statement <em>(not P) or (not Q)</em>.
</li>
<li>
    In general, the statement <em>not (P or Q)</em> has the same meaning as the statement <em>(not P) and (not Q)</em>.
</li>
</ul>
<p>
But how to prove these results? Well, let's draw the truth tables:
</p>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>¬P</th>
        <th>¬Q</th>
        <th>P ∧ Q</th>
        <th>¬(P ∧ Q)</th>
        <th>¬P ∨ ¬Q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
</table>
<p>
The table looks kind of messy, but everything we've worked out is just for the last two columns.
And guess what? They are exactly the same!
If two statements have the same column in the truth table,
then they are <strong>logically equivalent</strong> (≡).
In this case, we can therefore conclude that ¬(P ∧ Q) ≡ ¬P ∨ ¬Q.
</p>
<p>We can work out the same process for the other result:</p>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>¬P</th>
        <th>¬Q</th>
        <th>P ∨ Q</th>
        <th>¬(P ∨ Q)</th>
        <th>¬P ∧ ¬Q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
</table>
<p>The last two columns are also the same.
Therefore, ¬(P ∨ Q) ≡ ¬P ∧ ¬Q.
</p>
<dfn><div class="box">Remarks: </div></dfn>
<ol>
    <li>
        These two results are also called "De Morgan's laws".
        They can be very useful when you set the conditions for "if-else" statements in some programming languages.
    </li>
    <li>We can use the truth table to prove some other simple logical equivalence.
        For example, in the <strong>"2.1. Negations"</strong> section,
        we can see that "P" and "¬¬P"s' columns in the truth table are the same.
        We can therefore conclude that (P ≡ ¬¬P).
    </li>
    <li>
        Of course, this is not the only way to express the "logical equivalence".
        We will discover another way of expressing that in the "if and only if" section. 
    </li>
</ol>
<section id="c2-3"></section>
            <h3>2.3 If, then</h3>
<p>
Here it is, our protagonist in this chapter!
Remember the proofs we did before?
Usually, a statement we try to prove consists of hypotheses and a goal.
The hypotheses follow <strong>"if"</strong>, and the goal follows <strong>"then"</strong>.
If "P" is the hypothesis, and "Q" is the conclusion, we denote "if P, then Q" by (P → Q).
Here's the truth table:
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>P → Q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>True</td>
    </tr>
</table>
</p>
<p>
    You might find the last two rows, where 
    "if the hypothesis is false, then the statement must be true, regardless of the conclusion"
    to be confusing. Well, that's just how people define it.
    For example, consider this statement: If a dinosaur ate all the cherry trees on Quad yesterday,
    then all the books in Suzzallo Library become sandwiches at lunch time every day.
    In reality, it sounds ridiculous. But to mathematicians, it's a true statement, because the hypothesis is false: there's no dinosaur on Quad yesterday!
    Try evaluate the following statement:
</p>
<pre><code class="snippet"><div class="comment">-- 2.3.01</div>
#eval 10 < 5 → 3 = 4
</code></pre>
<p>It's true, right? Btw you can type "\r" in VS Code for "→".</p>
<p>
But these vacuous truths can be quite boring.
For most of the time, we want to prove (P → Q) to be true by assuming "P is true".
Why it works? Well, if we can assume that P is true, and show that Q must be true when P is true,
then the second row of the truth table for (P → Q) can never be reached.
Since we know that if P is false, then (P → Q) must be true,
we've' considered through all the situations where (P → Q) is true.
Thus, the following two examples are actually proving the same thing:
</p>
<pre><code class="snippet"><div class="comment">-- 2.3.02 (a)</div>
example {x : ℝ} (h : x = 2) : x^2 = 4 := by
  rw [h]
  norm_num
</code></pre>
<pre><code class="snippet"><div class="comment">-- 2.3.02 (b)</div>
example {x : ℝ} : x = 2 → x^2 = 4 := by
  intro h
  rw [h]
  norm_num
</code></pre>
<p>
However, if you look at the second example, you can see that we added an extra step at the beginning.
Since the first step to prove a statement (P → Q) is to assume P to be true,
we need to <strong>introduce</strong> the hypothesis that "P is true",
which is what the <code class="single_command">intro</code> tactic does.
<code class="single_command">intro h</code> just means to introduce an assumption named "h" from the hypothesis of the statement.
With this tactic, we change the goal from <code class="single_command">(P → Q)</code>
to a new hypothesis <code class="single_command">h : P</code> and a new goal <code class="single_command">Q</code>.
</p>
<dfn><div class="box">Bonus 1: </div></dfn>
<p>
If you look at the truth table, you can actually get another result:
If P is true and (P → Q) is true, then we can say that Q must be true!
This is a neat perspective, and this result is known as <strong>"modus ponens"</strong>.
In other word, if we already know that P is true and (P → Q) is true, we can prove that Q is true.
(e.g. if we know that a function is differentiable, 
and we know that a differentiable function must be continuous,
we can conclude the this function is also continuous!)
We can <strong>apply</strong> the conditional statement in the assumptions by using the <code class="single_command">apply</code> tactic:
</p>
<pre><code class="snippet"><div class="comment">-- 2.3.03</div>
example {P Q : Prop} (h1 : P) (h2 : P → Q) : Q := by
  apply h2
  exact h1
</code></pre>
<p>
Here, a hypothesis is <code class="single_command">h2 : P → Q</code>,
and the goal is <code class="single_command">Q</code>,
so <code class="single_command">apply h2</code> changes the goal from <code class="single_command">Q</code> to <code class="single_command">P</code>.
Then the goal is exactly the same as <code class="single_command">h1</code>. 
You can think of the functionality of <code class="single_command">apply</code> as to rewrite a goal 
from a conclusion back to a hypothesis based on a conditional statement you know to be true.
This is a big advantage of Lean: you can do the proofs backward!
</p>
<dfn><div class="box">Bonus 2: </div></dfn>
<p>
We usually want to prove that something is true based on the assumptions.
However, sometimes mathematicians want to prove something to be false! (the second row of the truth table).
This leads to the key idea of <em>proof by contradiction</em>, which we will cover in the next chapter.
</p>
            <h4>Negation of (P → Q)</h4>
<p>In the textbook, we know that ¬(P → Q) ≡ P ∧ ¬Q. Let's use the truth table to prove that.</p>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>P → Q</th>
        <th>¬P ∨ Q</th>
        <th>¬(P → Q)</th>
        <th>P ∧ ¬Q</th>
    </tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    </tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
    </tr>
    </tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    </tr>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
</table>
<p>
Based on the truth table, we can see that the third and fourth columns are the same,
so P → Q ≡ ¬P ∨ Q. The fifth and sixth columns are the same, so ¬(P → Q) ≡ P ∧ ¬Q.
Actually, you can also use De Morgan's laws and double negation to show that 
¬(P → Q) ≡ ¬(¬P ∨ Q) ≡ ¬¬P ∧ ¬Q ≡ P ∧ ¬Q.
If you don't like drawing the truth tables, you can also use some logical properties you know to prove the logical equivalences. 
</p>
            <h4>2.3.1. Converse and Contrapositive</h4>
<dfn><div class="box">Review: </div></dfn>
<p><strong><em>Definition 2.1.</em></strong> The converse of P → Q is the statement Q → P. The contrapositive of P  → Q is the
    statement (not Q) → (not P).</p>
    <table>
        <tr>
            <th>P</th>
            <th>Q</th>
            <th>¬P</th>
            <th>¬Q</th>
            <th>P → Q</th>
            <th>Q → P</th>
            <th>¬Q → ¬P</th>
        </tr>
        <tr>
            <td>True</td>
            <td>True</td>
            <td>False</td>
            <td>False</td>
            <td>True</td>
            <td>True</td>
            <td>True</td>
        </tr>
        <tr>
            <td>True</td>
            <td>False</td>
            <td>False</td>
            <td>True</td>
            <td>False</td>
            <td>True</td>
            <td>False</td>
        </tr>
        <tr>
            <td>False</td>
            <td>True</td>
            <td>True</td>
            <td>False</td>
            <td>True</td>
            <td>False</td>
            <td>True</td>
        </tr>
        <tr>
            <td>False</td>
            <td>False</td>
            <td>True</td>
            <td>True</td>
            <td>True</td>
            <td>True</td>
            <td>True</td>
        </tr>
    </table>
<p>
Look at the last three columns, you can see that P → Q <strong>is not equivalent</strong> to its <em>converse</em> Q → P.
However, P → Q <strong>is equivalent</strong> to its <em>contrapositive</em> ¬Q → ¬P.
</p>
<p>
This is an extremely useful fact! 
It means that proving P → Q is the same as proving ¬Q → ¬P since these two statements are logically equivalent.
Sometimes it's hard to prove P → Q, but it's easy to prove ¬Q → ¬P, 
so we can change out goal from P → Q to ¬Q → ¬P, 
which turns out to be a common proof technique: <em>proof by contrapositive</em>.
We will talk more about that in the next chapter.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<p>
    If you want to change your goal to its contrapositive, 
    just shout at your computer :"<strong>contrapose!</strong>"
    If nothing happens, you will then need to explicitly type the <code class="single_command">contrapose!</code> tactic.
</p>
<pre><code class="snippet"><div class="comment">-- 2.3.1.01</div>
example {P Q : Prop} (h : P → Q) : ¬Q → ¬P := by
  contrapose!
  exact h
</code></pre>
            <h4>2.3.2. if and only if</h4>
<p><strong><em>Definition 2.2.</em></strong> The statement P <strong>if and only if</strong> Q, written P ↔ Q, is equivalent to the statement
    (P → Q) and (Q → P).</p>
<p>As usual, let's draw the truth table. (Hopefully this is the last truth table in this chapter...)</p>
<table>
    <tr>
        <th>P</th>
        <th>Q</th>
        <th>P → Q</th>
        <th>Q → P</th>
        <th>(P → Q) ∧ (Q → P) [a.k.a. P ↔ Q]</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>True</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>True</td>
        <td>True</td>
        <td>True</td>
    </tr>
</table>
<p>
You can see that in order for P ↔ Q to be true, 
P and Q should have the same truth value (they should be both true or both false),
which means that P and Q should be <strong>logically equivalent</strong>.
This gives us another way of defining logical equivalence: 
<strong>P ≡ Q if P ↔ Q</strong>.
</p>
<p>
Also, since P ↔ Q is defined by (P → Q) ∧ (Q → P).
If we want to prove the statement P ↔ Q,
we should prove two things: (P → Q), and (Q → P).
Do you still rememer how we prove something with "∧" operator?
Yes, the <code class="single_command">constructor</code> tactic!
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- 2.3.1.01</div>
example {P Q : Prop} (h1 :  P → Q) (h2 : Q → P) : P ↔ Q := by
  constructor
    · exact h1
    · exact h2
</code></pre>
<p>
In VS Code, type "\iff" for "↔". 
"iff" means "if and only if".
</p>
<section id="c2-4"></section>
            <h3>2.4. Quantifiers</h3>
<p>One last thing before we end this chapter.</p>
<dfn><div class="box">Review: </div></dfn>
<ul>
    <li><strong><em>Universal Quantifier </em>(∀) - </strong></li> ∀x, P(x) ↔ For all x, P(x) is true.
    <li><strong><em>Existential Quantifier </em>(∃) - </strong></li> ∃x, P(x) ↔ There exists at least one x such that P(x) is true.
</ul>
<p>(In VS Code, type "\all" for "∀" and "\ex" for "∃".)</p>
<p>
Sometimes, we make a statement with the variable restricted in a certain <strong>set</strong> (which is also called <strong>domain of discourse</strong>).
For example, the statement "Every apple in the world is red" has the domain of discourse "all the apples in the world".
We can denote this statement as "∀ apple in the world, it's red."
Similarly, if we want to say that "At least one apple in the world is red", 
we can write "∃ an apple in the world such that it's red."
</p>
<p>
When I was learning the concepts of quantifiers,
I tried to relate them with the concepts I learned before,
and here's how I think about them:
<p>∀x, P(x)
means that every element x in the domain of discourse should satisfy P(x).
Suppose the domain of discourse is the set {a, b, c, b....}.
To make sure that ∀x, P(x), we need to have P(a) ∧ P(b) ∧ P(c) ∧ P(d) ∧...
Remember the truth table of conjunction (∧)? 
The only case where the conjunction of multiple statements is true is when all the statements are true,
which is exactly what the universal quantifier is used for.
</p>
<p>
Similarly, if you remember the truth table of disjunction (∨),
you should know that the only case where disjunction is false is that all the statements are false.
If <strong>at least one</strong> statement is true, the entire statement is true.
This is exactly how existential quantifier is defined! 
Suppose our domain of discourse is {a, b, c, d...} and our statement is: ∃x, P(x).
We only need to have P(a) ∨ P(b) ∨ P(c) ∨ P(d) ∨...
Even if only one element satisfies the statement, we can say that "∃x, P(x)" is true.
</p>
<p>
Now you see that we can always make analogies like these when talking about quantifiers.
Therefore, there are also four situations to consider:
</p>
<dfn><div class="box">In Lean: </div></dfn>
<p><strong><em>First situation: the goal includes </em>∃.</strong></p>
<p>Some mathematical concepts are defined using quantifiers.
We've seen in chapter 1 that the definitions of "divisibility" and "parity" both include existential quantifiers 
(e.g. The integer x is even if <em>there exists</em> an integer k such that x = k + k).
Did you remember how to prove the goal with "there exists" or "for some"? The <code class="single_command">use</code> tactic :D
</p>
<pre><code class="snippet"><div class="comment">-- 2.4.01 (a)</div>
example : ∃ n : ℝ, |n| > 0 := by
  use 1
  norm_num

</code></pre>
<pre><code class="snippet"><div class="comment">-- 2.4.01 (b)</div>
example : ∃ n : ℝ, |n| > 0 := by
  use -1
  norm_num
</code></pre>
<p>
This is an example from the textbook: There exists n such that |n| > 0.
To prove the goal with "there exists", we only need to <strong>use</strong> one specific example that satisfies the statement by using the <code class="single_command">use</code> tactic.
Since there are innumerous numbers that satisfies the statement, (in this case, all the real numbers, except 0, satisfies the statement),
we can choose any non-zero real number we want. 
In the examples above, 1 works, and -1 also works.
The <code class="single_command">use</code> tactic replaces the variable with the example we give.
Since we reduce the goal to a numerical expression, we can use <code class="single_command">norm_num</code> to close the goal.
</p>
<p><strong><em>Second situation: the goal includes </em>∀.</strong></p>
<p>
If the goal includes ∀, we need to show that every element in the domain of discourse satisfies the statement,
which is a very tedious thing to do.
If the domain of discourse is the entire set of real numbers, then...
well, we must find another way.
</p>
<p>
Luckily, we have a trick: to prove that "∀x, P(x)", 
we can assume an arbitrary element x from the domain of discourse.
Note that x must be <strong>an arbitrary element x</strong>, 
meaning that we can not have any other assumptions about this element.
Then this x can be used to represent any element in the domain of discourse.
If we prove that P(x) for this arbitrary element is true, 
we can therefore show that P(x) for every element is true.
To <strong>introduce</strong> this arbitrary element,
we need our old friend: <code class="single_command">intro</code> tactic.
</p>
<pre><code class="snippet"><div class="comment">-- 2.4.02</div>
example : ∀ n : ℝ, |n| ≥ 0 := by
  intro n
  norm_num
</code></pre>
<p>
This is also an example from the textbook.
To prove that "∀ n : ℝ, |n| ≥ 0", 
we first introduce an arbitrary real number n by typing <code class="single_command">intro n</code>.
After that, we have a new variable n, and our goal becomes "⊢ |n| ≥ 0".
Well, think about the definition of absolute value we learned in the first chapter,
it's easy to figure out that the absolute value of a real number is always greater than or equal to 0.
This is an axiom about real number, and surprise! <code class="single_command">norm_num</code> also works here.
(But don't abuse <code class="single_command">norm_num</code>! It typically doesn't work with variables.
We got lucky here because our goal is an axiom of real number.)
</p>
<p><strong><em>Third situation: the hypothesis includes </em>∃.</strong></p>
<p>
Consider this statement: If n is an even number, then n + 1 is an odd number.
This is a true statement, but how to prove that?
Well, let's unfold the definitions of even and odd number,
and we can rewrite the statement as the following equivalent statement:
If n = 2 * k₁ for some integer k₁, then n + 1 = 2 * k₂ + 1 for some integer k₂.
Now it's easy to prove: just let k₂ = k₁.
<p>
More specifically, the hypothesis is "∃ k, n = 2 * k",
so we know that there must be an integer k that satisfies n = 2 * k.
Even if we don't know the value of k here,
we can construct a variable k and a condition that n = 2 * k,
And here is the good news: you know what tactic we need to use.
We've discussed that we can relate existential quantifiers with disjunction (∨).
Which tactic is used for the situation where the hypothesis includes disjunction?
The <code class="single_command">cases'</code> tactic!
Whenever we want to seperate something from the hypothesis, we can just <code class="single_command">cases'</code> the hypothesis <code class="single_command">with</code> the things we want.
It's such a useful tactic!
</p>
<pre><code class="snippet"><div class="comment">-- 2.4.03</div>
example {n : ℤ} (h : Even n) : Odd (n + 1) := by
  cases' h with k newh 
  use k
  rw [newh]
  ring  
</code></pre>
<p>
Since the hypothesis <code class="single_command">(h : Even n)</code> is definitionally equivalent to <code class="single_command">(h : ∃ k : ℤ, n = 2 * k)</code>,
<code class="single_command">cases' h with k newh </code>
means to pull out a new variable <code class="single_command">k : ℤ</code> 
and a new hypothesis <code class="single_command">(newh : n = k + k)</code> from the hypothesis <code class="single_command">h</code>.
</p>
<p>
Now we have the variable k, what should we do next?
Since the goal <code class="single_command">Odd (n + 1)</code> is definitionally equivalent to <code class="single_command">∃ k : ℤ, n + 1 = 2 * k + 1</code>,
and we know how to prove the goal with "there exists"! 
We can use the variable <code class="single_command">k</code> we obtained to rewrite the goal as 
<code class="single_command">n + 1 = 2 * k + 1</code>.
</p>
<p>
We are close to our goal! 
We have the hypothesis that <code class="single_command">(newh : n = k + k)</code>,
so we can rewrite <code class="single_command">n</code> in the goal as  <code class="single_command">k + k</code>.
By using <code class="single_command">rw [newh]</code>, 
the goal becomes <code class="single_command">k + k + 1 = 2 * k + 1</code>.
</p>
<p>
Yeah! Our goal is reduced to high school algebra.
However, <code class="single_command">norm_num</code> will not work here because this expression includes variable,
and we have discussed that <code class="single_command">norm_num</code> doesn't deal with variables well.
If you do this on paper, you need to cite the properties of integers from the EPIs table.
But we are proving things on Lean, so...it's time to let you know one of the most powerful tactic in Lean 4: <code class="single_command">ring</code>. 
In this course, whenever your goal only involves some algebra of variables 
(i.e. an equality of expressions that only contains addition, multiplication, and exponents),
you can use <code class="single_command">ring</code> tactic to close the goal.
It can apply the properties of integers (associativity, commutativity, distribution law, etc.) all at once!
</p>
<p><strong><em>Fourth situation: the hypothesis includes </em>∀.</strong></p>
<p>
Actually, we've seen this situation already.
Consider our last example: If n is even, then n + 1 is odd.
We actually have a hidden assumption here: n must be an integer.
Therefore, the complete statement should be: For any integer n, if n is even, then n + 1 is odd.
We often omit the universal quantifier in a conditional statement, since it's easy to infer it from the statement.
And in Lean, we often have this hidden universal quantifier already when we declare the variables
(e.g. {n : ℤ} is the same as ∀ n : ℤ).
Thus, we don't really need to worry about this situation.
</p>
            <h4>2.4.1. Negations of quantified statements</h4>
<dfn><div class="box">Review: </div></dfn>
<ul>
    <li>¬(∀x, P(x)) ≡ ∃x, ¬P(x)</li>
    <li>¬(∃x, P(x)) ≡ ∀x, ¬P(x)</li>
</ul>
<p>
How to negate the statement that "every apple in the world is red"?
If you can find at least one apple that is not red, 
it's sufficient to say that the original statement is false,
and its negation that "at least an apple in the world is not red" is true.
You can also find some other examples to understand the second property.
Finding examples from real life is always a great way to study logic :)
</p>
<p>Now we have accomplished all the prerequisites!
Let's use the things we've learned so far to write some real and useful mathematical proofs :D</p>

        </section>

        <section>
            <section id="c3">
            <h2>Chapter 3: Writing Proofs</h2>
<p>
Finally! We are going to write some proofs.
In the following two chapters, we will use the tactics we learned from the first two chapters to write the <em>lean code version</em> of the proofs from the textbook.
Another way of saying that is to <strong>formalize the theorems from the textbook</strong>,
which sounds pretty cool!
</p>
<h4>Calculational Proofs</h4>
<p>
Before we dive into those different proof techniques, 
let's first take a look at the kind of proofs we've dealt with over the past 10 years: calculational proofs.
Maybe we can get some inspirations from that.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- 3.0.01 (complicated way) Prove that (x + y) * (x + y) = x * x + (x * y + y * x) + y * y</div>
example {x y : ℝ} : (x + y) * (x + y) = x * x + (x * y + y * x) + y * y := by
  calc
    _ = (x + y) * x + (x + y) * y := by exact mul_add (x + y) x y  <span class="comment">-- 5. The Distributive Law</span>
    _ = x * (x + y) + y * (x + y):= by rw [mul_comm (x + y) x, mul_comm (x + y) y]  <span class="comment">-- 3. Commutativity</span>
    _ = x * x + x * y + (y * x + y * y) := by rw [mul_add x x y, mul_add y x y]  <span class="comment">-- 5. The Distributive Law</span>
    _ = x * x + (x * y + (y * x + y * y)) := by rw [add_assoc (x * x) (x * y) (y * x + y * y)]  <span class="comment">-- 4. Associativity</span>
    _ = x * x + ((x * y + y * x) + y * y) := by rw [← add_assoc (x * y) (y * x) (y * y)]  <span class="comment">-- 4. Associativity</span>
    _ = x * x + (x * y + y * x) + y * y := by rw [← add_assoc (x * x) (x * y + y * x) (y * y)]  <span class="comment">-- 4. Associativity</span>
</code></pre>
<p>
If you want to prove an equality,
you can use the <code class="single_command">calc</code> keyword, 
and then follow this structure to do the calculation step by step.
Note that for each step you need to show the tactics you use to make such progress (after <code class="single_command">:= by</code>).
These commands can be found in first chapter's EPIs table.
</p>
<p>
Well, it looks really complicated, right? Here is a simple version:
</p>
<pre><code class="snippet"><div class="comment">-- 3.0.01 (simple way) Prove that (x + y) * (x + y) = x * x + (x * y + y * x) + y * y</div>
example {x y : ℝ} : (x + y) * (x + y) = x * x + (x * y + y * x) + y * y := by
  ring
</code></pre>
<p>
Yes, just type <code class="single_command">ring</code>, and the goal will be closed.
It applies all the basic properties of integers we use in the <code class="single_command">calc</code> version implicitly.
You don't need to do the algebra by yourself anymore.
</p>
<p>
So why did I show you the complicated way?
Well, first of all, <code class="single_command">calc</code> is just a command you'd better know as a Lean user.
And most importantly, the calculational proof shows that in order to prove something,
it is common to make progress <strong>step by step</strong>,
which therefore leads to the discussion about "direct proofs".
</p>
<section id="c3-1"></section>
            <h3>3.1. Direct Proofs</h3>
<dfn><div class="box">Review: </div></dfn>
<p>
    <strong>Theorem 3.1.</strong> If a and b are even integers, then a + b is even.
</p>
<p>
The textbook gives a clear proof of this theorem.
Let's see how we code a "Lean version" of this proof.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- theorem 3.1. If a and b are even integers, then a + b is even.</div>
theorem c3_1 {a b : ℤ} (h1 : Even a) (h2 : Even b) : Even (a + b) := by
  cases' h1 with k1 h1
  cases' h2 with k2 h2
  use k1 + k2
  rw [h1, h2]
  ring
</code></pre>
<p>
    If you find it hard to understand the proof, 
    try thinking about the definition of "even" as logical expression.
    That is, think about "even a" as "∃ k1 : ℤ, a = k1 + k1". Which tactic should you use to pull out something from a statement with existential quantifier?
    What about the goal?
</p>
<dfn><div class="box">Review: </div></dfn>
 <p>  <strong>Theorem 3.2.</strong> Suppose a, b, and c are integers. If a|b and b|c, then a|c.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- theorem 3.2. Suppose a, b, and c are integers. If a|b and b|c, then a|c.</div>
theorem c3_2 {a b c : ℤ} (h1 : a ∣ b) (h2 : b ∣ c) : a ∣ c := by
  cases' h1 with k h1
  cases' h2 with l h2
  use k * l
  rw [h2, h1]
  ring
</code></pre>
<p>
    That's it! We've successfully formalized two theorems from the textbook.
    Note that we use the "theorem" command here, instead of the "example" command we used before.
    The statement with "theorem" command can be used later.
    Remember the EPI's table? All the commands we gave you are theorems from the Mathlib!
</p>
<h4>So...How to use a theorem?</h4>
<p>A theorem typically looks like this:</p>
<p><code class="single_command">theorem_name {a b c ... : Type} (h : prop) ... : content := ...</code></p>
<p>Seems a little bit abstract. Let's see some real examples.
    To EPI 3 - commutativity, the theorem is called <code class="single_command">add_comm</code> in Mathlib.
    If you find that theorem in Mathlib, or if you move your cursor over the theorem somewhere in VS Code, it should look like this:
</p>
<p><code class="single_command">add_comm.{u_1} {G : Type u_1} [inst✝ : AddCommSemigroup G] (a b : G) : a + b = b + a</code></p>
<p>Well, after the theorem name, you don't need to worry about anything in curly braces { } and square brackets [ ].
    Those are called "implicit arguments", which Lean can infer by itself.
    You only need to start from things with parentheses ( ).
    Here, before the colon <code class="single_command">:</code>, 
    we see that <code class="single_command">(a b : G)</code>.
    Again, you don't need to know that G means here: just think of "integer" as a kind of G.
    Therefore, given two integers as arguments to the theorem <code class="single_command">add_comm a b</code>,
    it will return everything after the colon <code class="single_command">:</code>.
    In this case, <code class="single_command">add_comm a b</code> gives us <code class="single_command">a + b = b + a</code>, 
    a statement we can use by <code class="single_command">rw</code> or <code class="single_command">exact</code> tactic.
</p>
<p>
Another example is the theorem we proved above. Move your cursor over the theorem name, you can see that:
</p>
<p><code class="single_command">c3_1 {a b : ℤ} (h1 : Even a) (h2 : Even b) : Even (a + b)</code></p>
<p>
Start from the parentheses: there are two hypotheses enclosed by hypotheses.
Therefore, we need to give two propositions as arguments to the theorem, 
where the two propositions both indicate that an integer is even.
In our proof, if we have two propositions <code class="single_command">(h1 : Even a) (h2 : Even b)</code>,
we can then use this command:
</p>
<p><code class="single_command">c3_1 h1 h2</code></p>
<p>which returns the things after the colon <code class="single_command">: Even (a + b)</code>, 
    which is a statement we can use. </p>
<p>In short, if you want to use a theorem, just give it everything specified in the parentheses <strong>in order</strong>,
and then it will return the statement after the colon for you to use. 
We will do some practice in the next section.</p>
            <h4>3.1.1. Structure your proof in Lean</h4>
<p>Let's continue our discussion about the "step-by-step" proof from the beginning of this chapter. 
The two examples above are relatively simple and don't require much reasoning.
Oftentimes, however, a proof consists of many <em>intermediate steps</em>.
We all want lives to be easy, 
so if our goal is (P → Q),
we always want to check if there exists a theorem that is exactly the same as our goal,
and then use our lovely <code class="single_command">exact</code> tactic to close the goal directly.
Unfortunately, for most of the time we need to show an entire logic chain in order to prove something.
For example, to prove that (P → Q), we need to show that (P → R → S → T → U → V → W → ... → Q). 
If you find this to be frustrating, then ...... welcome to Mathematics.</p>
<p>
Let's take a simple example to see why this "logic chain" works.
</p>
<pre><code class="snippet"><div class="comment">-- 3.1.01 If P → R, and R → Q, then P → Q.</div>
example {P Q R : Prop} (h1 : P → R) (h2 : R → Q) : P → Q := by
  intro h
  apply h2
  apply h1
  exact h
</code></pre>
<p>
Using the tactics we learned before, we proved that "If P → R, and R → Q, then P → Q."
In fact, as you follow this pattern, you can have as many intermediate propositions as you want.
As long as the logic chain begins with P and ends with Q, you can always show that (P → Q).
Therefore, we've proved that "a chain of implications" does work. 
And most importantly, we are now able to use Lean to prove something that's not proved in the textbook! That's amazing!!
</p>
<p>
Let's see a real example of it. Consider this statement: If a and b are even integers, then 2 | a + b.
De ja vu? It's actually equivelent to <strong>theorem 3.1.</strong> - "if a and b are even, then a + b is even."
(a + b is even ≡ ∃ k, a + b = 2k ≡ 2 | a + b). 
In fact, 2 divides any even integer! 
Therefore, we can first use the result from <strong>theorem 3.1.</strong>
to show that if a and b are both even, then a + b is even, and then unfold the definition of even number and divisibility of prove that 2 | a + b, which means:
in order to prove (Even a ∧ Even b → 2 | a + b), we can add an intermediate step:
(Even a ∧ Even b → Even (a + b) → 2 | a + b).
</p>
<p>
So how can we construct the intermediate steps of a proof in Lean?
For most of the time, we want to prove (P → Q), 
but we don't have the hypotheses like (h1 : P → R) and (h2 : R → Q)
that are explicitly written in the problem, so we need to <strong>have</strong> our own hypotheses as the intermediate steps by using the
<code class="single_command">have</code> tactic.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- 3.1.04 If a and b are even integers, then 2 ∣ a + b</div>
example {a b : ℤ} (h1 : Even a) (h2 : Even b) : 2 ∣ a + b := by
  have h3 : Even (a + b) := by
    exact c3_1 h1 h2
  cases' h3 with k h4
  use k
  rw [h4]
  ring
</code></pre>
<p>
Remember: our first step is to prove that a + b is an even integer.
To add this intermediate step, we use the <code class="single_command">have</code> tactic, 
and give this step a name. 
Since it will become the third hypothesis of this statement, we name it <code class="single_command">h3</code> here.
After the colon we state the content of this step: <code class="single_command">Even (a + b)</code>.
Finally, we type <code class="single_command">:= by</code> to indicate that we are going to prove it.
As you hit "enter" + "tab", you will see that in the "current proof state" in your Lean Infoview window,
the goal becomes the statement we are proving in this step.
This is a <em>subgoal</em> of our whole proof. 
We use indentation to indicate that we are proving a subgoal, 
and Lean's current proof state will only show the subgoal to help us focus on it.
In this case,
since the subgoal is already proved in this Lean file, we can use the theorem directly by the <code class="single_command">exact</code> tactic.
We named this theorem "c3_1" above, which takes two hypotheses 
<code class="single_command">(h1 : Even a) (h2 : Even b)</code>
and outputs the result <code class="single_command">Even (a + b)</code>.
(We've seen how to use a theorem.)
In this case, "c3_1" needs to take two arguments that are the hypotheses to show that a and b are even,
so we type <code class="single_command">c3_1 h1 h2</code>,
and it will return the output (<code class="single_command">Even (a + b)</code>).
Since it's exactly the same as this subgoal, we use <code class="single_command">exact</code> tactic.
After we complete the proof of a subgoal, we exit this indentation block, 
and Lean will show us the main goal again.
Then you can use this new hypothesis and some tactics to close this main goal as usual.
</p>
<section id="c3-2"></section>
            <h3>3.2. Proof by Cases (a.k.a. proof by exhaustion)</h3>
<p>
From last chapter, 
we've shown that in order to prove things like ((P ∨ Q) → R),
we need to prove that (P → R) ∧ (Q → R).
You can draw a truth table to show that these two statements are actually logically equivalent,
but we have three variables here, so our truth table has 2^3 = 8 rows,
and it becomes very tedious to draw a truth table for it.
Let's see if we can apply some properties of logic to prove this equivelance.
</p>
<dfn><div class="box">Review: </div></dfn>
<ul>
    <li>Law of Implication: P → Q ≡ ¬P ∨ Q</li>
    <li>De Morgan's Laws (1): ¬(P ∧ Q) ≡  ¬P ∨ ¬Q</li> 
    <li>De Morgan's Laws (2): ¬(P ∨ Q) ≡  ¬P ∧ ¬Q</li>
    <li>Distributive Laws (1): P ∧ (Q ∨ R) ≡ (P ∧ Q) ∨ (P ∧ R) </li>
    <li>Distributive Laws (2): P ∨ (Q ∧ R) ≡ (P ∨ Q) ∧ (P ∨ R) </li>
</ul>
<p>
We've seen the first three properties from the last chapter.
You might be unfamiliar with the last two properties, 
but it's not difficult to memorize them: they are very similar to the distrubutive law in arithmetic.
</p>
<p>
Applying these properties, we have:</p>
<p>
(P ∨ Q) → R ≡ ¬(P ∨ Q) ∨ R ≡ (¬P ∧ ¬Q) ∨ R ≡ (¬P ∨ R) ∧ (¬Q ∨ R) ≡ (P → R) ∧ (Q → R).
</p>
<p>
We've proved the underlying logic of <em>proof by cases</em>!
</p>

<dfn><div class="box">Review: </div></dfn>
<p><strong>Theorem 3.3.</strong> The product of two consecutive integers is even.</p>
<dfn><div class="box">In Lean: </div></dfn>
<p>
The textbook first states the fact that an integer is either even or odd.
Well, we can't just do the same thing in Lean: we need to prove it or use the theorem that's proved somewhere else. 
We will prove its contrapositive later in this chapter, but for now let's use the theorem from Mathlib.
You might have already seen that we imported "Mathlib.Data.Int.Parity" at the beginning of the file.
It has the following theorem we will use:
</p>
<p><code class="single_command">Int.even_or_odd (n : ℤ) : Even n ∨ Odd n</code></p>
<p>It states that an integer is even or odd. 
    If we type <code class="single_command">Int.even_or_odd n</code>, where n is an integer declared ealier,
it will output <code class="single_command">Even n ∨ Odd n</code>. This is all we need!</p>
<pre><code class="snippet"><div class="comment">-- 3.2.1 (Theorem 3.3.) The product of two consecutive integers is even.</div>
theorem c3_3 (n : ℤ) : Even (n * (n + 1)) := by
  have h : Even n ∨ Odd n := by
    exact Int.even_or_odd n
  cases' h with heven hodd
  · cases' heven with k heven
    use k * (n + 1)
    rw [heven]
    ring
  · cases' hodd with k hodd
    use n * (k + 1)
    rw [hodd]
    ring
</code></pre>
<dfn><div class="box">Review: </div></dfn>
<p><strong>Theorem 3.4.</strong> (Elementary Properties of Absolute Value). Suppose a and b are integers. Then:</p>
<ul>
<li>(a) |a| ≥ 0.</li>
<li>(b) |−a| = |a|.</li>
<li>(c) −|a| ≤ a ≤ |a|.</li>
<li>(d) |a|^2 = a^2.</li>
<li>(e) |ab| = |a||b|.</li>
<li>(f) |a| ≤ |b| if and only if −|b| ≤ a ≤ |b|.</li>
</ul>
<dfn><div class="box">In Lean: </div></dfn>
<p>We will use the theorem of trichotomy from EPIs table:</p>
<p><code class="single_command">lt_trichotomy.{u} {α : Type u} [inst✝ : LinearOrder α] (a b : α) : a < b ∨ a = b ∨ b < a</code></p>
<p>Again, just look at things in the parentheses: <code class="single_command">(a b : α)</code>.
Before chapter 5, please take my words: I will always give you the right theorem, 
so don't worry about what α means here. It's a problem about integers, so just input two integers.
In chapter 5, I will explain more about what {α : Type u} means here. By that time,
you should be able to understand any theorem and later look for theorems by yourself.
Let's take time :)</p>
<p>To prove these theorems, let me introduce two new powerful tactics for you.
    They are really really powerful!
</p>
            <h4>3.2.01 rcases</h5>
<p>If b is 0, then <code class="single_command">lt_trichotomy a 0</code> will outputs 
<code class="single_command">a < 0 ∨ a = 0 ∨ 0 < a</code>.
It's slightly different from the textbook, which has three cases, but they are essentially the same:
"a ≥ 0" is equivalent to "a > 0 ∨ a = 0".</p>
<p>
You might want to use <code class="single_command">cases'</code> tactic,
but I forgot to tell you one fact: <code class="single_command">cases'</code> can only seperate a statement to two statements.
In this case, it is only able to split the output to <code class="single_command">a < 0</code> and <code class="single_command">a = 0 ∨ a > 0</code>,
as Lean pull out statements from logical connectives in order. 
Frustratingly, you need to use <code class="single_command">cases'</code> again to split the second statement to two statements.
</p>
<p>
Is there one way to seperate the cases all at once? There is!
We can do this <strong>recursively</strong> by <code class="single_command">rcases</code> command. "r" stands for "recursive".
</p>
<p>If the hypothesis is <code class="single_command">h : P ∨ Q ∨ R</code>, 
type <code class="single_command">rcases h with hp | hq | hr</code> to seperate the hypothesis to 
<code class="single_command">hp: P</code>, <code class="single_command">hq: Q</code>, and <code class="single_command">hr: R</code>. 
If the hypothesis is <code class="single_command">h : P ∧ Q ∧ R</code>, 
    type <code class="single_command">rcases h with ⟨hp hq hr⟩</code> to seperate the hypothesis to 
    <code class="single_command">hp: P</code>, <code class="single_command">hq: Q</code>, and <code class="single_command">hr: R</code>. 
In short, <code class="single_command">|</code> for disjunctions, and <code class="single_command">⟨⟩</code> for conjunctions.
In VS Code, type "\<" for "⟨" and "\>" for "⟩". 
This tactic is a recursive version of <code class="single_command">cases'</code>,
so it can do everything that <code class="single_command">cases'</code> can do. 
Feel free to stick to it.
</p>
            <h4>3.2.02 linarith</h5>
<p>The proof in the textbook use the fact that if a < 0, then -a > 0.
This is an example of <strong>linear inequality</strong>.
For any goal as linear equalities and inequalities, with enough information provided in the assumptions, you can use the <code class="single_command">linarith</code> tactic.
For example, if the assumptions are <code class="single_command">(h1 : a < b)</code> and <code class="single_command">(h2 : b < c)</code>
and your goal is <code class="single_command">a < c</code>, just type <code class="single_command">linarith</code>.
It will close the goal immediately. Keep in mind that the expression should be <strong>linear</strong>,
which means the variables are linearly combined.
It's a powerful tactic, but don't use it everywhere blindly.

</p>
<p>Also, two axioms about absolute value for you ~ (I omit some unimportant information)</p>
<p><code class="single_command">abs_of_neg ... {a : α} (h : a < 0) : |a| = -a</code></p>
<p><code class="single_command">abs_of_pos ... {a : α} (h : 0 < a) : |a| = a</code></p>
<pre><code class="snippet"><div class="comment">-- 3.2.2 |a| ≥ 0.</div>
theorem c3_4_1 {a : ℤ} : |a| ≥ 0 := by
  have h : a < 0 ∨ a = 0 ∨ a > 0 := by
    exact lt_trichotomy a 0
  rcases h with h1 | h2 | h3
    · have h : |a| = -a := by
        exact abs_of_neg h1
      rw [h]
      linarith
    · have h : |a| = a:= by
        rw [h2]
        exact abs_zero
      rw [h]
      linarith
    · have h : |a| = a := by
        exact abs_of_pos h3
      rw [h]
      linarith
</code></pre>

<pre><code class="snippet"><div class="comment">-- 3.2.3. |-a| = |a|</div>
theorem c3_4_2 {a : ℤ} : |-a| = |a| := by
  have h : a < 0 ∨ a = 0 ∨ a > 0 := by
    exact lt_trichotomy a 0
  rcases h with h1 | h2 | h3
    · have h : -a > 0 := by
        linarith
      rw [abs_of_pos h, abs_of_neg h1]
    · rw [h2]
      norm_num
    · have h : -a < 0 := by
        linarith
      rw [abs_of_neg h, abs_of_pos h3]
      ring
</code></pre>


            <h3>3.3. Proof by contrapositive</h3>
<p>
Recall that P → Q ≡ ¬Q → ¬P. To change a goal from P → Q to ¬Q → ¬P in a Lean proof,
use the <code class="single_command">contrapose!</code> tactic.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<div class="unfinished">theorem 3.6, 3.7 proof. </div>
<section id="c3-4"></section>
            <h3>3.4. Proof by contradiction</h3>
<p>
That's it! This is my favorite form of proof :) Let's see why and how it works.
</p>
<p>
Let's first introduce two new terms: tautology and contradiciton.
A tautology is always true, while a contradiction is always false.
For example:
</p>
<table>
<tr>
    <th>P</th>
    <th>¬P</th>
    <th>P ∨ ¬P</th>
</tr>
<tr>
    <td>True</td>
    <td>False</td>
    <td>True</td>
</tr>
<tr>
    <td>False</td>
    <td>True</td>
    <td>True</td>
</tr>
</table>
<p>
We can see that (P ∨ ¬P) is true in all cases, so (P ∨ ¬P) is a tautology.
</p>
<table>
    <tr>
        <th>P</th>
        <th>¬P</th>
        <th>P ∧ ¬P</th>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>False</td>
        <td>True</td>
        <td>False</td>
    </tr>
</table>
<p>
We can see that (P ∧ ¬P) is false in all cases, so (P ∧ ¬P) is a contradiction.
(These two results are also called "Negation Laws".)
</p>
<p>
Now let's see the definition of <em>proof by contradiction</em> from the textbook:
In a proof by contradiction, we use the fact that a statement and its negation have opposite truth values.
To prove that P is true, suppose instead that not(P) is true and apply logic, definitions, and previous
results to arrive at a conclusion you know to be false. Then you may conclude that not(P) must be
FALSE and thus P must be TRUE.
</p>
<p>
In short: To prove P, we need to show that (¬P → C), where C stands for contradiction.
Let's draw a truth table:
</p>
<table>
    <tr>
        <th>P</th>
        <th>C</th>
        <th>¬P → C</th>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>True</td>
    </tr>
    <tr>
        <td>False</td>
        <td>False</td>
        <td>False</td>
    </tr>
</table>
<p>
P and (¬P → C) are logically equivalent, which shows why proof by contradiction works.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<p>
If we want to prove by contradiction in Lean 4,
we need two steps:
first step is to negate the goal and make it as a new hypothesis (assume the negation of our goal);
second step is to change our goal to "false", which is how Lean denotes contradiction.
Luckily, there is a tactic called <code class="single_command">by_contra</code>
that can complete these two steps at once. 
</p>
<pre><code class="snippet"><div class="comment">-- 3.4.01 If P is true, then P is true</div>
example {P : Prop} (h : P) : P := by
  by_contra h1
  contradiction
</code></pre>
<p>
We can just use <code class="single_command">exact h</code> to close the goal,
but for a demo of proof by contradiction in Lean, let's use <code class="single_command">by_contra h1</code> here,
which creates a new hypothesis <code class="single_command">h1 : ¬P</code>, (which is the negation of the original goal  <code class="single_command">⊢ P</code>), 
and changes the goal to <code class="single_command">⊢ False</code>.
</p>
<p>
OK, so now we have two hypotheses: <code class="single_command">h : P</code> and <code class="single_command">h1 : ¬P</code>. 
The <strong>contradiction</strong> is so obvious!
Whenever we see a <strong>contradiction</strong> in our hypotheses,
we can use <code class="single_command">contradiction</code> tactic to close the goal immediately.
</p>
<p>
Remark: <code class="single_command">contradiction</code> can close any goal with contradictory hypotheses.
Remember that if the hypothesis is false, the the statement is vacuously true, right?
</p>
<div class="unfinished">theorem 3.8, 3.9, 3.10 proof. might use intro</div>
<section id="c3-5"></section>
            <h3>3.5. Proof of an if-and-only-if Statement</h3>
<p>
    Suppose we want to prove (P ↔ Q) in Lean, and we know that (P ↔ Q) is the same as (P → Q) ∧ (Q → P),
    so our goal is actually a conjunction. Therefore, we need to use the <code class="single_command">constructor</code> tactic to split our goal to (P → Q) and (Q → P).
    (you can review chapter 2 if you don't remember this)
</p>

<div class="unfinished">theorem 3.11 proof. </div>
        </section>

        <section>
            <section id="c4">
            <h2>Chapter 4: Proofs Involving Quantifiers</h2>
            <section id="c4-1"></section>
            <h3>4.1. Proofs of <em>for all</em> statements</h3> 
<dfn><div class="box">Review: </div></dfn>
<p>
    Remember that in chapter 2,
    we showed that the universal quantifier (∀) and the hypothesis of the conditional statement (if...then...) are quite similar.
    Here is an example from the textbook:
</p>
<p>The statement "<em>for all integers x, P(x)</em>"
is equivalent to the statement "<em>if x is an integer, then P(x).</em>"
</p>   
<p>
Therefore, we can use the same method to prove a statement with "for all..." and a statement with "if..."
by <strong>introducing</strong> an arbitrary variable and reduce our goal to the remaining part of the statements.
Does it ring a bell? Yes! The <code class="single_command">intro</code> tactic! 
Whenever you see something like (∀ x..., P(x)) or (if x ..., then P(x)), 
use <code class="single_command">intro x</code> to add x as 
a variable to your assumption and reduce your goal to <code class="single_command">P(x)</code>.
This tactic is sooooooooo useful!
</p>
<div class="unfinished">theorem 4.1 proof</div>
<section id="c4-2"></section>
            <h3>4.2. Proofs of <em>there exist</em> statements</h3> 
<dfn><div class="box">Review: </div></dfn>
<p>
Since "there exists" is much weaker than "for all", when we prove a statement with <em>"there exists an x such that P(x)"</em> (∃x, P(x)),
we only need to <strong>use</strong> one example of x that satisfies P(x). 
In Lean 4, this can be simply done by the <code class="single_command">use</code> tactic.
If we are able to <strong>construct</strong> specific examples to prove the statement, then we are using "<strong>constructive proof</strong>".
Let's implement some examples from textbook in Lean:
</p>
<dfn><div class="box">In Lean: </div></dfn>
<pre><code class="snippet"><div class="comment">-- 4.2.01 There exist integers m and n such that 10m + 13n = 3.</div>
example : ∃ m n : ℤ, 10 * m + 13 * n = 3 := by
  use -1, 1
  norm_num
</code></pre>
<p>
To prove that "there exist integers m and n such that 10m + 13n = 3",
we can just give speficic examples of "m" and "n" that satisfy the equation.
In this case, <code class="single_command">use -1, 1</code> means that 
we use "-1" for "m" and "1" for "n". 
Then the goal is reduced to an expression with numbers, and we can use 
<code class="single_command">norm_num</code> to close the goal.
</p>
<pre><code class="snippet"><div class="comment">-- 4.2.02 For every integer a, there exists an integer b such that a + b = 1.</div>
example : ∀ a : ℤ, ∃ b : ℤ, a + b = 1 := by
  intro a
  use 1 - a
  ring
</code></pre>
<p>
If you see some quantifiers being used together, don't panic, 
as you will get used to that in your real analysis class...
Just use the techniques we learned to reduce to goal in sequence.
<strong>It's important to follow the sequence of quantifiers!
("∀ a : ℤ, ∃ b : ℤ" and "∃ b : ℤ, ∀ a : ℤ" are not the same thing!)
</strong>
In this case, we see <code class="single_command">∀ a : ℤ</code> first,
so we intro the arbitrary variable  <code class="single_command">a</code>.
Then we construct a specific example <code class="single_command">1 - a</code>
and use it to replace b in the goal. Then the goal is reduced to an algebraic expression with variable,
and we can use <code class="single_command">ring</code> to close the goal.
</p>
<section id="c4-3"></section>
            <h3>4.3. Existence and uniqueness</h3> 
<p>
To prove "existence" (∃), we only need to give one example. 
There might be other examples that also satisfy the same proposition,
but one example is enough.
</p>
<p>
To prove "uniqueness" (∃!), however, we not only need to give an example,
but also need to show that that's the only example that can satisfy the proposition.
In other words, besides the basic steps of proving existence,
we need one more step:
we assume that there exist another example that also satisfies the same proposition.
But after some deduction, we find that the two examples are actually the same.
</p>
<p>
I know it sounds a little bit abstract. 
Let's follow the textbook and see how to prove uniqueness in Lean.
</p>
<dfn><div class="box">In Lean: </div></dfn>
<div class="unfinished">theorem 4.2, 4.3 proof, intro to dsimp</div>
        </section>

        <section>
            <section id="c5">
            <h2>Chapter 5: Sets</h2>
<p>
Welcome to the chapter of set theory!
</p>
<dfn><div class="box">Review: </div></dfn>
<p>
<ul>
<li><strong><em>set: </em></strong>a collection of elements</li>
<li><strong><em>empty set (∅): </em></strong>a set with no elements (type "\empty" for "∅")</li>
</ul>
</p>
<dfn><div class="box">In Lean: </div></dfn>
<p>In textbook we can see that there are many ways of specifying a set.
</p>
<p>
In mathematics, if we want to describe a set with certain elements,
we can list them explicitly (e.g. {1, 2, 3}). 
In this chapter, however, we'd like to prove more general features of sets
instead of taking specific examples.
Also, it's a little bit complicated to implement the reasoning of this kind of sets in Lean 4,
so we will not focus on it.
</p>
<p> Another common way is to use the <strong>set-builder</strong> notation.
As an example from the textbook, if we want to describe a set with all integers between 5 and 103,
we write {x ∈ ℤ : 5 ≤ x ≤ 103}. This notation consists of two parts:
a variable, and a statement specifying the properties of the set.
In Lean 4, we can describe the same set in this way:
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.01</div>
#check {x : ℤ | x ≥ 5 ∧ x ≤ 103}
</code></pre>
<p>If you move your cursor over <code class="single_command">#check</code>,
you can see that it Lean describes this set as "Set ℤ", which means that 
it's a set of integers. <code class="single_command">#check</code>
command can show the <strong>type</strong> of a certain expression.
</p>
<p>Wait, what is a <strong>type</strong>?</p>
<section id="c5-0"></section>
            <h3>5.0. Type</h3>
<p>
If you have some programming experience,
you might notice that in a programming language (e.g. Java), different variables can have different kinds of data types
(integer, float, character, boolean, etc.).
If you don't, no worries! You just need to know that in programming,
a term is usually associated with a type. (e.g. "6" has the type "integer", "hello" has the type "string").
The study of such type systems is called <strong>type theory</strong>,
which is what Lean, as a programming language, is based on.</p>
<p>
In Lean, everything has a type, and we can use the <code class="single_command">#check</code> command to check its type.
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.02</div>
#check 1
#check 1.5
#check (1 : ℝ)
</code></pre>
<p>
In Lean 4, the notation we use to show that "a has type b" is "a : b". 
You can see that "1" has the type "ℕ" (1 : ℕ), meaning that 1 is an natural number.
Note that ℕ is a type which means "natural number" in Lean 4, instead of "natural number set".
This is the <strong>key difference </strong>between set theory and type theory!
It's why we denote it as "1 : ℕ" instead of "1 ∈ ℕ" in Lean.
</p>
<p>
<code class="single_command">#check 1.5</code> gives us "1.5 : Float",
so 1.5 has the type "Float". Seems like the numbers have default types in Lean.
But what if we don't want the default type of a specific number?
For example, we want 1 to be treated as a real number instead of an natural number.
Well, it's easy: just explicitly type <code class="single_command">(1 : ℝ)</code>,
and Lean will treat 1 as a real number <em>in that expression</em>.
</p>
<p>
If we want to declare some variables and assign them specific types,
we just need to follow the same format:
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.03</div>
variable (a b : ℤ)
variable (P : Prop)
</code></pre>
<p>
Here, we declare variables "a" and "b" with type "integer".
We also declare a variable "P" with type "Prop", meaning that it's a propositional variable.
Seems familiar? That's right! For every example we've done before,
we always declare the variables with their types in this way.
If we declare variables inside an example, then the variables can only be seen and used in that example.
But if we declare a variable as the way above, then they can be seen until the end of the file!
Different ways of declaring variables lead to different <strong>scopes</strong> of variables.
If you want to restrict the scope of some variables in a certain part of the file,
use the <code class="single_command">section</code> and <code class="single_command">end</code> keywords,
so that the variables declared between these two keywords will also have scope only in this part.
You might've already seen these a lot in the exercise files.
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.04</div>
section
variable (a b : ℤ)
variable (P : Prop)
end
</code></pre>
<p>
What about some types (like ℕ and ℝ) themselves? Are they also variables of certain types?
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.05</div>
#check ℕ
#check ℝ
</code></pre>
<p>
The answer is "yes". ℕ and ℝ have the type "Type"...
I will not go deeper than this.
If you are confused, just remember: a type itself can also have a type.
</p>
<p>
Alright, I almost forget that this is a chapter of sets.
In Lean, if we want to declare a variable as a set,
we need to specifically show that it's a set of a certain type.
For example, "Set ℤ" means that it's a set of "integer" type.
In this chapter, we will prove some general things about sets,
so we declare a new variable with the type "Type" and then declare another variable to be the set of that type.
</p>
<pre><code class="snippet"><div class="comment">-- 5.0.06</div>
section
variable (α : Type)
variable (A : Set α)
end
</code></pre>
<p>
In this case, we declare a new type "α", and declare the variable A to be the set of type "α".
For most of the exercises of set theory, we will follow this format,
so you will get used to that very soon. 
</p>
<p>
Now guess what? We've gone through the most difficult part in this chapter!
The following content will just be a review of basic set theory stuff from your textbook
with their implementations in Lean 4,
and you already know all the tactics we will be using!
Before that, let's take a break :)
</p>
<section id="c5-1"></section>
            <h3>5.1. Union</h3>
<p>
For this chapter, I will first declare some variables of sets for all the examples
of this chapter. These variables will be implicitly available to all the problems in this chapter,
so that I don't need to write the same things over and over again for each example.
</p>
<pre><code class="snippet"><span class="comment">-- Declare variables of sets for all the problems in this chapter</span>
variable {α : Type} {A B C D : Set α}
</code></pre>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B ("\union" for "∪")</li>
<li>A ∪ B = B ∪ A</li>
<li>A ∪ A = A</li>
</ul>
<section id="c5-2"></section>
            <h3>5.2. Intersection</h3>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B ("\inter" for "∩")</li>
<li>A ∩ B = B ∩ A</li>
<li>A ∩ A = A</li>
<li>A and B are disjoint ↔ A ∩ B = ∅</li>
</ul>
<section id="c5-3"></section>
            <h3>5.3. Subsets</h3>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>A ⊆ B ↔ ∀ x, x ∈ A → x ∈ B</li>
<li>∅ is a subset of all sets, including itself.</li>
<li><strong>Theorem 5.1.</strong> Let A, B, C and D be sets. Suppose A ⊆ B and C ⊆ D. Then A ∪ C ⊆ B ∪ D.</li>
</ul>
<dfn><div class="box">In Lean: </div></dfn>
<p>
Let's prove the second and third statements in Lean.
A key thing to remember: <em>always think of the logical expressions of the concepts' definitions.</em>
</p>
<pre><code class="snippet"><div class="comment">-- 5.3.01</div>
example : ∅ ⊆ A := by
  intro x
  intro h
  contradiction
</code></pre>
<p>
Let A be an arbitrary set, and we proved that the empty set is a subset of A.
The proof is short, but it might not be that intuitive in the first place.
So think about the definition of our goal: what does "∅ ⊆ A" mean?
it's equivalent to "∀ x, x ∈ ∅ → x ∈ A", right?
We know how to prove a statement like that!
It starts with "∀", so we use <code class="single_command">intro x</code> command to introduce an arbitrary variable x.
Now the goal reduces to "x ∈ ∅ → x ∈ A". It's a conditional statement,
so we still use the <code class="single_command">intro</code> tactic to introduce a new hypothesis <code class="single_command">(h : x ∈ ∅)</code>.
The goal is then reduced to only "x ∈ A". 
But since the hypothesis h is always false, as an empty set cannot have any element,
we can use <code class="single_command">contradiction</code> to close the goal. Not difficult, right?
As long as you can think of the set theoretic notations as logical expressions.
</p>
<pre><code class="snippet"><span class="comment">-- 5.3.02 (Theorem 5.1.) Let A, B, C and D be sets. </span>
<span class="comment">-- Suppose A ⊆ B and C ⊆ D. Then A ∪ C ⊆ B ∪ D.</span>
example (h1 : A ⊆ B) (h2 : C ⊆ D) : A ∪ C ⊆ B ∪ D := by
  intro x
  intro h3
  cases' h3 with h3 h4
  · have h5 : x ∈ B := by
      exact h1 h3
    left
    exact h5
  · have h6 : x ∈ D := by
      exact h2 h4
    right
    exact h6
</code></pre>
<p>
This example is slightly longer, but trust me: you can understand everything in this proof 
(review chapter 2 if you forgot some of the tactics). Here are some hints :)
</p>
<ul>
<li>A ∪ C ⊆ B ∪ D ↔ ∀ x, x ∈ A ∪ C → x ∈ B ∪ D</li>
<li>A ⊆ B ↔ ∀ x, x ∈ A → x ∈ B</li>
<li>C ⊆ D ↔ ∀ x, x ∈ C → x ∈ D</li>
<li>if a hypothesis is of this form: <code class="single_command">(h1 : P → Q)</code>,
and another hypothesis is of this form: <code class="single_command">(h2 : P)</code>,
then <code class="single_command">h1 h2</code> outputs <code class="single_command">Q</code>.
You can think of a conditional statement as a function that takes the proof of the hypothesis as an input and outputs the conclusion.
In this case, <code class="single_command">(h1 : P → Q)</code> is a function that takes <code class="single_command">(h2 : P)</code> as an input and outputs <code class="single_command">Q</code>.
</ul>
<section id="c5-4"></section>
            <h3>5.4. Set equality</h3>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>A = B ↔ A ⊆ B ∧ B ⊆ A.</li>
</ul>
<dfn><div class="box">In Lean: </div></dfn>
<p>
Set equality is essentially a conjunction, so we can use <code class="single_command">constructor</code> command to seperate the main goal to subgoals.
However, Lean 4 doesn't handle "A = B ↔ A ⊆ B ∧ B ⊆ A" implicitly, 
so we need to use a theorem from the package "Mathlib.Data.Set.Basic" called <code class="single_command">Set.Subset.antisymm_iff</code>.
In practice, if the goal is <code class="single_command">A = B</code>, then
<code class="single_command">rw [Set.Subset.antisymm_iff]</code> changes the goal to <code class="single_command">A ⊆ B ∧ B ⊆ A</code>.
</p>
<section id="c5-5"></section>
            <h3>5.5. Set Difference</h3>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>x ∈ A \ B ↔ x ∈ A ∧ x ∉ B ("\\" for "\", "\notin" for "∉")</li> 
<li><strong>Theorem 5.2.</strong> Let A be a set. Then A \ A = ∅.</li>
<li><strong>Theorem 5.3.</strong> Let A, B, and C be sets. Then A \ (B ∪ C) = (A \ B) ∩ (A \ C).</li>
</ul>
<p>Notes (delete after): a theorem for 5.2, de morgan's laws for 5.3, same variable names for different goals</p>  
<dfn><div class="box">In Lean: </div></dfn>
<p>
We will exactly follow the textbook's ways of proving these two theorems.
</p>
<p>
In the textbook, the theorem 5.2. is proved by contradiction.
It uses the fact that if a set is not empty, then there exists en element in the set.
We need to use a theorem from "Mathlib.Data.Set.Basic" called 
<code class="single_command">Set.eq_empty_iff_forall_not_mem</code>,
which states that <code class="single_command">s = ∅ ↔ ∀ (x : α), x ∉ s</code>,
where s is some set. Using this theorem, we can rewrite the goal from 
<code class="single_command">A \ A = ∅</code> to <code class="single_command">∀ (x : α), x ∉ A \ A</code>.
After introducing the arbitrary variable x, just follow the process of proof by contradiction.
</p>
<pre><code class="snippet"><span class="comment">-- 5.5.01 (Theorem 5.2.) Let A be a set. Then A \ A = ∅. </span>
example : A \ A = ∅ := by
  rw [Set.eq_empty_iff_forall_not_mem]
  intro x
  by_contra h
  cases' h with h1 h2
  contradiction
</code></pre>
<p>
In the textbook, the proof for theorem 5.3. uses the fact that "x ∉ A ∪ B ↔ x ∉ A ∧ x ∉ B".
This is a result from <em>De Morgan's Laws of sets</em>. 
Since the textbook doesn't require you to prove it
(or you've already proved it, depends on your instructor's requirement), 
I implement this theorem in the file of this chapter for you to use directly.
The theorem is called <code class="single_command">notin_union_iff_notin_and_notin</code>,
which states that <code class="single_command">x ∉ A ∪ B ↔ x ∉ A ∧ x ∉ B</code>.
Though not required, you are welcome to check how it's implemented.
</p>
<p>
Another friendly reminder: If there are subgoals in your proof,
after each subgoal is closed, the variables you declared in the subgoal will also disappear,
so that you can use the same variable names for other subgoals.
</p>
<pre><code class="snippet"><span class="comment">-- 5.5.02 (Theorem 5.3.) Let A, B, and C be sets. 
                         Then A \ (B ∪ C) = (A \ B) ∩ (A \ C).</span>
example : A \ (B ∪ C) = (A \ B) ∩ (A \ C) := by
  rw [Set.Subset.antisymm_iff]
  constructor
  -- ⊢ A \ (B ∪ C) ⊆ A \ B ∩ (A \ C)
  · intro x
    intro h1
    cases' h1 with h1 h2
    rw [notin_union_iff_notin_and_notin] at h2
    cases' h2 with h2 h3
    have h4 : x ∈ A \ B := by
      constructor
      · exact h1
      · exact h2
    have h5 : x ∈ A \ C := by
      constructor
      · exact h1
      · exact h3
    constructor
    · exact h4
    · exact h5
  -- ⊢ A \ B ∩ (A \ C) ⊆ A \ (B ∪ C)
  · intro x
    intro h1
    cases' h1 with h1 h2
    cases' h1 with h11 h12
    cases' h2 with h21 h22
    constructor
    · exact h11
    · have h3 : x ∉ B ∧ x ∉ C := by
        constructor
        · exact h12
        · exact h22
        rw [notin_union_iff_notin_and_notin]
        exact h3
</code></pre>
<p>
The proof looks scary, but if you can understand the proof on the textbook, then you can also understand this one.
At the second half of this guide we will introduce some other techniques for writing shorter proofs in Lean.
</p>
<section id="c5-6"></section>
            <h3>5.6. Sets of sets</h3>
<dfn><div class="box">Review: </div></dfn>
<ul>
<li>Sets of sets are also called <em>families</em>.</li>
<li><strong>Definition 5.1.</strong> The power set of a set A is the set of all subsets of A, written as 𝒫(A). ("\power" for "𝒫")</li>
<li>∀ A, ∅ ∈ 𝒫(A)</li>
<li><strong>Theorem 5.4.</strong> Let A and B be sets. Then 𝒫(A) ⊆ 𝒫(A ∪ B)</li>
<li><strong>Theorem 5.5.</strong> Let A and B be sets. Then A ∩ B = ∅ if and only if 𝒫(A) ∩ 𝒫(B) = {∅}.</li>
</ul>
<dfn><div class="box">In Lean: </div></dfn>
command for definition, intro two at the same time, find theorems by self
            <h4>5.6.1. Unions and Intersections of Families</h3>
<dfn><div class="box">Review: </div></dfn>
<p>If F is a family, then:</p>
<ul>
<li>∪ F = {a : there exists A ∈ F with a ∈ A}</li>
<li>∩ F = {a : for all A ∈ F,a ∈ A}</li>
<li><strong>Theorem 5.6.</strong> Let A and B be families. Then ⋃ (A ∩ B) ⊆ (⋃ A) ∩ (⋃ B).</li>
</ul>
        </section>
        <section>
            <section id="c6">
            <h2>Chapter 6: Proofs by Induction</h2>
            <p>This is the content of Chapter 6.</p>
        </section>
        <section>
            <section id="c7">
            <h2>Chapter 7: Relations</h2>
            <p>This is the content of Chapter 7.</p>
        </section>
        <section>
            <section id="c8">
            <h2>Chapter 8: Congruences</h2>
            <p>This is the content of Chapter 8.</p>
        </section>
        <section>
            <section id="c9">
            <h2>Chapter 9: Functions</h2>
            <p>This is the content of Chapter 9.</p>
        </section>
        <section>
            <section id="c10">
            <h2>Chapter 10: Cardinality</h2>
            <p>This is the content of Chapter 11.</p>
        </section>
        <section>
            <section id="c11">
            <h2>(Optional) Chapter 11: Dependent Type Theory</h2>
            <p>This is the content of Chapter 11.</p>
        </section>
    </main>

    <footer>

    </footer>

    <script>
        window.onload = function() {
            const chapterHeaders = document.querySelectorAll('nav.sidebar ul > li > a');
            const mainContent = document.querySelector('main'); 
    
            chapterHeaders.forEach(header => {
                header.addEventListener('click', function(event) {
                    const subMenu = this.nextElementSibling;
    
                    if (subMenu && subMenu.tagName === 'UL') {
                        subMenu.classList.toggle('hidden');
                        event.preventDefault(); 
    
                        const chapterId = this.getAttribute('href').substring(1);
                        const chapterElement = document.getElementById(chapterId);
                        if (chapterElement) {
                            chapterElement.scrollIntoView(); 
                        }
                    } else {
                        window.location.hash = this.getAttribute('href');
                    }
                });
            });
    
            document.querySelectorAll('nav.sidebar ul > li > ul').forEach(function(subMenu) {
                subMenu.classList.add('hidden');
            });
    
            document.getElementById('expand-all').addEventListener('click', function() {
                document.querySelectorAll('nav.sidebar ul > li > ul').forEach(function(subMenu) {
                    subMenu.classList.remove('hidden');
                });
            });
    
            document.getElementById('collapse-all').addEventListener('click', function() {
                document.querySelectorAll('nav.sidebar ul > li > ul').forEach(function(subMenu) {
                    subMenu.classList.add('hidden');
                });
            });
    
            document.getElementById('toggle-sidebar-btn').addEventListener('click', function() {
                const sidebar = document.querySelector('.sidebar');
                sidebar.classList.toggle('sidebar-hidden');
                mainContent.classList.toggle('full-width'); // 控制主内容区域的宽度
                this.textContent = sidebar.classList.contains('sidebar-hidden') ? 'Open Bar' : 'Close Bar';
            });
        };
    </script>
    
    
    
      
      

</body>
</html>
